{"instruction": "Refactor this Rust function to be under 50 lines (sw-checklist requirement).", "input": "fn process_records(records: Vec<Record>) -> Result<Summary, Error> {\n    let mut total = 0;\n    let mut count = 0;\n    let mut errors = Vec::new();\n    let mut warnings = Vec::new();\n    let mut by_category: HashMap<String, Vec<Record>> = HashMap::new();\n\n    for record in &records {\n        if record.value < 0 {\n            errors.push(format!(\"Negative value in record {}\", record.id));\n            continue;\n        }\n        if record.value == 0 {\n            warnings.push(format!(\"Zero value in record {}\", record.id));\n        }\n        total += record.value;\n        count += 1;\n        by_category\n            .entry(record.category.clone())\n            .or_default()\n            .push(record.clone());\n    }\n\n    let average = if count > 0 { total / count } else { 0 };\n\n    let mut category_summaries = Vec::new();\n    for (cat, cat_records) in &by_category {\n        let cat_total: i64 = cat_records.iter().map(|r| r.value).sum();\n        let cat_avg = cat_total / cat_records.len() as i64;\n        let cat_max = cat_records.iter().map(|r| r.value).max().unwrap_or(0);\n        let cat_min = cat_records.iter().map(|r| r.value).min().unwrap_or(0);\n        category_summaries.push(CategorySummary {\n            name: cat.clone(),\n            count: cat_records.len(),\n            total: cat_total,\n            average: cat_avg,\n            max: cat_max,\n            min: cat_min,\n        });\n    }\n\n    category_summaries.sort_by(|a, b| b.total.cmp(&a.total));\n\n    if !errors.is_empty() {\n        return Err(Error::ValidationErrors(errors));\n    }\n\n    Ok(Summary {\n        total,\n        count,\n        average,\n        warnings,\n        categories: category_summaries,\n    })\n}", "output": "fn validate_records(records: &[Record]) -> Result<(), Vec<String>> {\n    let errors: Vec<String> = records\n        .iter()\n        .filter(|r| r.value < 0)\n        .map(|r| format!(\"Negative value in record {}\", r.id))\n        .collect();\n    if errors.is_empty() { Ok(()) } else { Err(errors) }\n}\n\nfn collect_warnings(records: &[Record]) -> Vec<String> {\n    records\n        .iter()\n        .filter(|r| r.value == 0)\n        .map(|r| format!(\"Zero value in record {}\", r.id))\n        .collect()\n}\n\nfn summarize_category(name: &str, records: &[Record]) -> CategorySummary {\n    let total: i64 = records.iter().map(|r| r.value).sum();\n    CategorySummary {\n        name: name.to_string(),\n        count: records.len(),\n        total,\n        average: total / records.len().max(1) as i64,\n        max: records.iter().map(|r| r.value).max().unwrap_or(0),\n        min: records.iter().map(|r| r.value).min().unwrap_or(0),\n    }\n}\n\nfn process_records(records: Vec<Record>) -> Result<Summary, Error> {\n    if let Err(errors) = validate_records(&records) {\n        return Err(Error::ValidationErrors(errors));\n    }\n\n    let valid: Vec<_> = records.iter().filter(|r| r.value >= 0).collect();\n    let total: i64 = valid.iter().map(|r| r.value).sum();\n    let count = valid.len();\n\n    let mut by_cat: HashMap<String, Vec<Record>> = HashMap::new();\n    for r in &valid {\n        by_cat.entry(r.category.clone()).or_default().push((*r).clone());\n    }\n\n    let mut categories: Vec<_> = by_cat\n        .iter()\n        .map(|(name, recs)| summarize_category(name, recs))\n        .collect();\n    categories.sort_by(|a, b| b.total.cmp(&a.total));\n\n    Ok(Summary {\n        total,\n        count,\n        average: if count > 0 { total / count as i64 } else { 0 },\n        warnings: collect_warnings(&records),\n        categories,\n    })\n}", "pattern": "function_loc_refactor", "error_hint": "Function has too many lines (max 50). Split into smaller focused functions."}
