{"instruction": "Fix: cannot borrow `v` as mutable because it is also borrowed as immutable\n\nBuggy code:\n```rust\nfn main() { let mut v = vec![1, 2, 3]; let first = &v[0]; v.push(4); println!(\"{}\", first); }\n```", "output": "```rust\nfn main() { let mut v = vec![1, 2, 3]; let first = v[0]; v.push(4); println!(\"{}\", first); }\n```"}
{"instruction": "Fix: cannot borrow `data` as mutable because it is also borrowed as immutable\n\nBuggy code:\n```rust\nfn main() { let mut data = vec![10, 20, 30]; let x = &data[1]; data.push(40); println!(\"{}\", x); }\n```", "output": "```rust\nfn main() { let mut data = vec![10, 20, 30]; let x = data[1]; data.push(40); println!(\"{}\", x); }\n```"}
{"instruction": "Fix: cannot borrow `items` as mutable because it is also borrowed as immutable\n\nBuggy code:\n```rust\nfn main() { let mut items = vec![String::from(\"a\")]; let first = &items[0]; items.push(String::from(\"b\")); println!(\"{}\", first); }\n```", "output": "```rust\nfn main() { let mut items = vec![String::from(\"a\")]; let first = items[0].clone(); items.push(String::from(\"b\")); println!(\"{}\", first); }\n```"}
{"instruction": "Fix: cannot borrow `nums` as mutable because it is also borrowed as immutable\n\nBuggy code:\n```rust\nfn main() { let mut nums = vec![1, 2]; let sum: i32 = nums.iter().sum(); nums.push(sum); }\n```", "output": "```rust\nfn main() { let mut nums = vec![1, 2]; let sum: i32 = nums.iter().sum(); nums.push(sum); }\n```"}
{"instruction": "Fix: cannot borrow `v` as mutable because it is also borrowed as immutable\n\nBuggy code:\n```rust\nfn main() { let mut v = vec![1, 2, 3]; let len = &v.len(); v.push(4); println!(\"{}\", len); }\n```", "output": "```rust\nfn main() { let mut v = vec![1, 2, 3]; let len = v.len(); v.push(4); println!(\"{}\", len); }\n```"}
{"instruction": "Fix: cannot borrow `arr` as mutable because it is also borrowed as immutable\n\nBuggy code:\n```rust\nfn main() { let mut arr = vec![5, 10, 15]; let last = &arr[arr.len()-1]; arr.push(20); println!(\"{}\", last); }\n```", "output": "```rust\nfn main() { let mut arr = vec![5, 10, 15]; let last = arr[arr.len()-1]; arr.push(20); println!(\"{}\", last); }\n```"}
{"instruction": "Fix: cannot borrow `s.items` as mutable because it is also borrowed as immutable\n\nBuggy code:\n```rust\nstruct S { items: Vec<i32> } fn main() { let mut s = S { items: vec![1] }; let x = &s.items[0]; s.items.push(2); println!(\"{}\", x); }\n```", "output": "```rust\nstruct S { items: Vec<i32> } fn main() { let mut s = S { items: vec![1] }; let x = s.items[0]; s.items.push(2); println!(\"{}\", x); }\n```"}
{"instruction": "Fix: cannot borrow `buffer` as mutable because it is also borrowed as immutable\n\nBuggy code:\n```rust\nfn main() { let mut buffer = vec![1, 2, 3]; for &x in &buffer { buffer.push(x * 2); } }\n```", "output": "```rust\nfn main() { let mut buffer = vec![1, 2, 3]; let doubled: Vec<_> = buffer.iter().map(|&x| x * 2).collect(); buffer.extend(doubled); }\n```"}
{"instruction": "Fix: cannot borrow `s` as mutable more than once at a time\n\nBuggy code:\n```rust\nfn main() { let mut s = String::from(\"hello\"); let r1 = &mut s; let r2 = &mut s; println!(\"{} {}\", r1, r2); }\n```", "output": "```rust\nfn main() { let mut s = String::from(\"hello\"); let r1 = &mut s; println!(\"{}\", r1); let r2 = &mut s; println!(\"{}\", r2); }\n```"}
{"instruction": "Fix: cannot borrow `v` as mutable more than once at a time\n\nBuggy code:\n```rust\nfn main() { let mut v = Vec::new(); let a = &mut v; let b = &mut v; a.push(1); b.push(2); }\n```", "output": "```rust\nfn main() { let mut v = Vec::new(); let a = &mut v; a.push(1); let b = &mut v; b.push(2); }\n```"}
{"instruction": "Fix: cannot borrow `data` as mutable more than once at a time\n\nBuggy code:\n```rust\nfn main() { let mut data = vec![1, 2, 3]; let x = &mut data; let y = &mut data; x.push(4); y.push(5); }\n```", "output": "```rust\nfn main() { let mut data = vec![1, 2, 3]; { let x = &mut data; x.push(4); } { let y = &mut data; y.push(5); } }\n```"}
{"instruction": "Fix: cannot borrow `text` as mutable more than once at a time\n\nBuggy code:\n```rust\nfn main() { let mut text = String::from(\"hi\"); let a = &mut text; let b = &mut text; a.push('!'); b.push('?'); }\n```", "output": "```rust\nfn main() { let mut text = String::from(\"hi\"); let a = &mut text; a.push('!'); let b = &mut text; b.push('?'); }\n```"}
{"instruction": "Fix: cannot borrow `nums` as mutable more than once at a time\n\nBuggy code:\n```rust\nfn add(v: &mut Vec<i32>, x: i32) { v.push(x); } fn main() { let mut nums = vec![]; let a = &mut nums; let b = &mut nums; add(a, 1); add(b, 2); }\n```", "output": "```rust\nfn add(v: &mut Vec<i32>, x: i32) { v.push(x); } fn main() { let mut nums = vec![]; add(&mut nums, 1); add(&mut nums, 2); }\n```"}
{"instruction": "Fix: cannot borrow `arr` as mutable more than once at a time\n\nBuggy code:\n```rust\nfn main() { let mut arr = [1, 2]; let a = &mut arr[0]; let b = &mut arr[1]; std::mem::swap(a, b); }\n```", "output": "```rust\nfn main() { let mut arr = [1, 2]; arr.swap(0, 1); }\n```"}
{"instruction": "Fix: cannot borrow `list` as mutable more than once at a time\n\nBuggy code:\n```rust\nfn main() { let mut list = vec![1, 2]; let a = &mut list; let b = &mut list; a.clear(); b.push(3); }\n```", "output": "```rust\nfn main() { let mut list = vec![1, 2]; list.clear(); list.push(3); }\n```"}
{"instruction": "Fix: returns a reference to data owned by the current function\n\nBuggy code:\n```rust\nfn get_str() -> &str { let s = String::from(\"hello\"); &s }\n```", "output": "```rust\nfn get_str() -> String { String::from(\"hello\") }\n```"}
{"instruction": "Fix: returns a reference to data owned by the current function\n\nBuggy code:\n```rust\nfn make_greeting(name: &str) -> &str { let s = format!(\"Hello, {}!\", name); &s }\n```", "output": "```rust\nfn make_greeting(name: &str) -> String { format!(\"Hello, {}!\", name) }\n```"}
{"instruction": "Fix: returns a reference to data owned by the current function\n\nBuggy code:\n```rust\nfn get_vec() -> &Vec<i32> { let v = vec![1, 2, 3]; &v }\n```", "output": "```rust\nfn get_vec() -> Vec<i32> { vec![1, 2, 3] }\n```"}
{"instruction": "Fix: returns a reference to data owned by the current function\n\nBuggy code:\n```rust\nfn get_slice() -> &[i32] { let v = vec![1, 2, 3]; &v[..] }\n```", "output": "```rust\nfn get_slice() -> Vec<i32> { vec![1, 2, 3] }\n```"}
{"instruction": "Fix: returns a reference to data owned by the current function\n\nBuggy code:\n```rust\nstruct Data { value: String } fn get_value() -> &str { let d = Data { value: String::from(\"test\") }; &d.value }\n```", "output": "```rust\nstruct Data { value: String } fn get_value() -> String { let d = Data { value: String::from(\"test\") }; d.value }\n```"}
{"instruction": "Fix: returns a reference to data owned by the current function\n\nBuggy code:\n```rust\nfn concat(a: &str, b: &str) -> &str { let result = format!(\"{}{}\", a, b); &result }\n```", "output": "```rust\nfn concat(a: &str, b: &str) -> String { format!(\"{}{}\", a, b) }\n```"}
{"instruction": "Fix: returns a reference to data owned by the current function\n\nBuggy code:\n```rust\nfn make_box() -> &i32 { let b = Box::new(42); &*b }\n```", "output": "```rust\nfn make_box() -> Box<i32> { Box::new(42) }\n```"}
{"instruction": "Fix: returns a reference to data owned by the current function\n\nBuggy code:\n```rust\nfn get_arr() -> &[u8] { let arr = [1u8, 2, 3]; &arr }\n```", "output": "```rust\nfn get_arr() -> Vec<u8> { vec![1u8, 2, 3] }\n```"}
{"instruction": "Fix: no method named `clone` found; the trait `Clone` is not implemented\n\nBuggy code:\n```rust\nstruct Data { value: i32 } fn main() { let d = Data { value: 42 }; let d2 = d.clone(); }\n```", "output": "```rust\n#[derive(Clone)] struct Data { value: i32 } fn main() { let d = Data { value: 42 }; let d2 = d.clone(); }\n```"}
{"instruction": "Fix: no method named `clone` found; the trait `Clone` is not implemented\n\nBuggy code:\n```rust\nstruct Person { name: String, age: u32 } fn main() { let p = Person { name: String::from(\"Alice\"), age: 30 }; let p2 = p.clone(); }\n```", "output": "```rust\n#[derive(Clone)] struct Person { name: String, age: u32 } fn main() { let p = Person { name: String::from(\"Alice\"), age: 30 }; let p2 = p.clone(); }\n```"}
{"instruction": "Fix: no method named `clone` found; the trait `Clone` is not implemented\n\nBuggy code:\n```rust\nstruct Container { items: Vec<i32> } fn main() { let c = Container { items: vec![1, 2] }; let c2 = c.clone(); }\n```", "output": "```rust\n#[derive(Clone)] struct Container { items: Vec<i32> } fn main() { let c = Container { items: vec![1, 2] }; let c2 = c.clone(); }\n```"}
{"instruction": "Fix: no method named `clone` found; the trait `Clone` is not implemented\n\nBuggy code:\n```rust\nstruct Point(i32, i32); fn main() { let p = Point(1, 2); let p2 = p.clone(); }\n```", "output": "```rust\n#[derive(Clone)] struct Point(i32, i32); fn main() { let p = Point(1, 2); let p2 = p.clone(); }\n```"}
{"instruction": "Fix: no method named `clone` found; the trait `Clone` is not implemented\n\nBuggy code:\n```rust\nstruct Config { debug: bool } fn copy_config(c: &Config) -> Config { c.clone() }\n```", "output": "```rust\n#[derive(Clone)] struct Config { debug: bool } fn copy_config(c: &Config) -> Config { c.clone() }\n```"}
{"instruction": "Fix: no method named `clone` found; the trait `Clone` is not implemented\n\nBuggy code:\n```rust\n#[derive(Debug)] struct Item { id: u64 } fn main() { let i = Item { id: 1 }; let i2 = i.clone(); }\n```", "output": "```rust\n#[derive(Debug, Clone)] struct Item { id: u64 } fn main() { let i = Item { id: 1 }; let i2 = i.clone(); }\n```"}
{"instruction": "Fix: no method named `clone` found; the trait `Clone` is not implemented\n\nBuggy code:\n```rust\nstruct Entry { key: String } fn main() { let entries = vec![Entry { key: String::from(\"a\") }]; let copy = entries.clone(); }\n```", "output": "```rust\n#[derive(Clone)] struct Entry { key: String } fn main() { let entries = vec![Entry { key: String::from(\"a\") }]; let copy = entries.clone(); }\n```"}
{"instruction": "Fix: the trait `Hash` is not implemented for `Key`\n\nBuggy code:\n```rust\nuse std::collections::HashMap; struct Key { id: i32 } fn main() { let mut map = HashMap::new(); map.insert(Key { id: 1 }, \"value\"); }\n```", "output": "```rust\nuse std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Key { id: i32 } fn main() { let mut map = HashMap::new(); map.insert(Key { id: 1 }, \"value\"); }\n```"}
{"instruction": "Fix: the trait `Hash` is not implemented for `UserId`\n\nBuggy code:\n```rust\nuse std::collections::HashMap; struct UserId { name: String } fn main() { let mut users = HashMap::new(); users.insert(UserId { name: String::from(\"alice\") }, 100); }\n```", "output": "```rust\nuse std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct UserId { name: String } fn main() { let mut users = HashMap::new(); users.insert(UserId { name: String::from(\"alice\") }, 100); }\n```"}
{"instruction": "Fix: the trait `Hash` is not implemented for `Item`\n\nBuggy code:\n```rust\nuse std::collections::HashSet; struct Item { code: u32 } fn main() { let mut set = HashSet::new(); set.insert(Item { code: 42 }); }\n```", "output": "```rust\nuse std::collections::HashSet; #[derive(Hash, PartialEq, Eq)] struct Item { code: u32 } fn main() { let mut set = HashSet::new(); set.insert(Item { code: 42 }); }\n```"}
{"instruction": "Fix: the trait `Hash` is not implemented for `Coord`\n\nBuggy code:\n```rust\nuse std::collections::HashMap; struct Coord(i32, i32); fn main() { let mut grid = HashMap::new(); grid.insert(Coord(0, 0), true); }\n```", "output": "```rust\nuse std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Coord(i32, i32); fn main() { let mut grid = HashMap::new(); grid.insert(Coord(0, 0), true); }\n```"}
{"instruction": "Fix: the trait `Hash` is not implemented for `Id`\n\nBuggy code:\n```rust\nuse std::collections::HashMap; #[derive(Debug, Clone)] struct Id { val: i64 } fn main() { let mut m = HashMap::new(); m.insert(Id { val: 1 }, \"x\"); }\n```", "output": "```rust\nuse std::collections::HashMap; #[derive(Debug, Clone, Hash, PartialEq, Eq)] struct Id { val: i64 } fn main() { let mut m = HashMap::new(); m.insert(Id { val: 1 }, \"x\"); }\n```"}
{"instruction": "Fix: the trait `Hash` is not implemented for `CacheKey`\n\nBuggy code:\n```rust\nuse std::collections::HashMap; struct CacheKey { prefix: String, id: u32 } fn main() { let mut cache = HashMap::new(); cache.insert(CacheKey { prefix: String::from(\"user\"), id: 1 }, vec![]); }\n```", "output": "```rust\nuse std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct CacheKey { prefix: String, id: u32 } fn main() { let mut cache = HashMap::new(); cache.insert(CacheKey { prefix: String::from(\"user\"), id: 1 }, vec![]); }\n```"}
{"instruction": "Fix: the trait `Ord` is not implemented for `Score`\n\nBuggy code:\n```rust\nstruct Score { value: i32 } fn main() { let mut scores = vec![Score { value: 3 }, Score { value: 1 }]; scores.sort(); }\n```", "output": "```rust\n#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Score { value: i32 } fn main() { let mut scores = vec![Score { value: 3 }, Score { value: 1 }]; scores.sort(); }\n```"}
{"instruction": "Fix: the trait `Ord` is not implemented for `Entry`\n\nBuggy code:\n```rust\nstruct Entry { priority: u32, name: String } fn main() { let mut entries = vec![Entry { priority: 2, name: String::from(\"b\") }]; entries.sort(); }\n```", "output": "```rust\n#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Entry { priority: u32, name: String } fn main() { let mut entries = vec![Entry { priority: 2, name: String::from(\"b\") }]; entries.sort(); }\n```"}
{"instruction": "Fix: the trait `Ord` is not implemented for `Task`\n\nBuggy code:\n```rust\nuse std::collections::BinaryHeap; struct Task { priority: i32 } fn main() { let mut heap = BinaryHeap::new(); heap.push(Task { priority: 5 }); }\n```", "output": "```rust\nuse std::collections::BinaryHeap; #[derive(PartialEq, Eq, PartialOrd, Ord)] struct Task { priority: i32 } fn main() { let mut heap = BinaryHeap::new(); heap.push(Task { priority: 5 }); }\n```"}
{"instruction": "Fix: the trait `Ord` is not implemented for `Key`\n\nBuggy code:\n```rust\nuse std::collections::BTreeSet; struct Key { id: i32 } fn main() { let mut set = BTreeSet::new(); set.insert(Key { id: 1 }); }\n```", "output": "```rust\nuse std::collections::BTreeSet; #[derive(PartialEq, Eq, PartialOrd, Ord)] struct Key { id: i32 } fn main() { let mut set = BTreeSet::new(); set.insert(Key { id: 1 }); }\n```"}
{"instruction": "Fix: the trait `Ord` is not implemented for `Item`\n\nBuggy code:\n```rust\nstruct Item { weight: u32 } fn main() { let mut items = vec![Item { weight: 10 }]; items.sort(); }\n```", "output": "```rust\n#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Item { weight: u32 } fn main() { let mut items = vec![Item { weight: 10 }]; items.sort(); }\n```"}
{"instruction": "Fix: the trait `Ord` is not implemented for `Rank`\n\nBuggy code:\n```rust\nstruct Rank(u32); fn main() { let mut ranks = vec![Rank(3), Rank(1), Rank(2)]; ranks.sort(); }\n```", "output": "```rust\n#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Rank(u32); fn main() { let mut ranks = vec![Rank(3), Rank(1), Rank(2)]; ranks.sort(); }\n```"}
{"instruction": "Fix: the trait `Ord` is not implemented for `Value`\n\nBuggy code:\n```rust\nstruct Value { n: i32 } fn main() { let vals = vec![Value { n: 5 }, Value { n: 2 }]; let m = vals.iter().max(); }\n```", "output": "```rust\n#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Value { n: i32 } fn main() { let vals = vec![Value { n: 5 }, Value { n: 2 }]; let m = vals.iter().max(); }\n```"}
{"instruction": "Fix: expected `Result<i32, &str>`, found `Option<i32>`\n\nBuggy code:\n```rust\nfn parse_first(v: &[&str]) -> Result<i32, &str> { v.first().map(|s| s.parse().unwrap()) }\n```", "output": "```rust\nfn parse_first(v: &[&str]) -> Result<i32, &str> { v.first().ok_or(\"empty\")?.parse().map_err(|_| \"parse error\") }\n```"}
{"instruction": "Fix: expected `Result<_, _>`, found `Option<_>`\n\nBuggy code:\n```rust\nfn get_value(opt: Option<i32>) -> Result<i32, &'static str> { opt }\n```", "output": "```rust\nfn get_value(opt: Option<i32>) -> Result<i32, &'static str> { opt.ok_or(\"no value\") }\n```"}
{"instruction": "Fix: expected `Result<String, &str>`, found `Option<String>`\n\nBuggy code:\n```rust\nfn get_name(data: Option<&str>) -> Result<String, &str> { data.map(|s| s.to_uppercase()) }\n```", "output": "```rust\nfn get_name(data: Option<&str>) -> Result<String, &str> { data.map(|s| s.to_uppercase()).ok_or(\"missing\") }\n```"}
{"instruction": "Fix: the `?` operator can only be applied to values that implement `Try`\n\nBuggy code:\n```rust\nfn find_user(id: u32) -> Result<String, &'static str> { let users = vec![(1, \"alice\")]; users.iter().find(|(i, _)| *i == id).map(|(_, n)| n.to_string()) }\n```", "output": "```rust\nfn find_user(id: u32) -> Result<String, &'static str> { let users = vec![(1, \"alice\")]; users.iter().find(|(i, _)| *i == id).map(|(_, n)| n.to_string()).ok_or(\"not found\") }\n```"}
{"instruction": "Fix: expected `Result<&i32, &str>`, found `Option<&i32>`\n\nBuggy code:\n```rust\nuse std::collections::HashMap; fn lookup(m: &HashMap<String, i32>, k: &str) -> Result<&i32, &str> { m.get(k) }\n```", "output": "```rust\nuse std::collections::HashMap; fn lookup(m: &HashMap<String, i32>, k: &str) -> Result<&i32, &str> { m.get(k).ok_or(\"key not found\") }\n```"}
{"instruction": "Fix: expected `Result<&T, E>`, found `Option<&T>`\n\nBuggy code:\n```rust\nfn get_item<T>(v: &[T], idx: usize) -> Result<&T, &'static str> { v.get(idx) }\n```", "output": "```rust\nfn get_item<T>(v: &[T], idx: usize) -> Result<&T, &'static str> { v.get(idx).ok_or(\"index out of bounds\") }\n```"}
{"instruction": "Fix: expected `Result<_, String>`, found `Option<_>`\n\nBuggy code:\n```rust\nfn parse_env(key: &str) -> Result<String, String> { std::env::var(key).ok().filter(|s| !s.is_empty()) }\n```", "output": "```rust\nfn parse_env(key: &str) -> Result<String, String> { std::env::var(key).ok().filter(|s| !s.is_empty()).ok_or_else(|| format!(\"missing or empty: {}\", key)) }\n```"}
{"instruction": "Fix: expected `Result<&i32, &str>`, found `Option<&i32>`\n\nBuggy code:\n```rust\nfn head(v: &[i32]) -> Result<&i32, &str> { v.first() }\n```", "output": "```rust\nfn head(v: &[i32]) -> Result<&i32, &str> { v.first().ok_or(\"empty slice\") }\n```"}
