{"instruction": "You are a Yew/WASM expert. Fix the following Yew frontend component code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse yew::prelude::*;\n\n#[function_component(Counter)]\nfn counter() {\n    let count = use_state(|| 0);\n    html! {\n        <div>{\"Count: \"}{*count}</div>\n    }\n}\n```\n\n## Fixed Code:", "output": "use yew::prelude::*;\n\n#[function_component(Counter)]\nfn counter() -> Html {\n    let count = use_state(|| 0);\n    html! {\n        <div>{\"Count: \"}{*count}</div>\n    }\n}", "task_id": "yew_001", "domain": "yew_wasm"}
{"instruction": "You are a Yew/WASM expert. Fix the following Yew frontend component code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse yew::prelude::*;\n\n#[function_component(Button)]\nfn button() -> Html {\n    let count = use_state(|| 0);\n    let onclick = Callback::from(|_| {\n        count.set(*count + 1);\n    });\n    html! { <button {onclick}>{\"Click\"}</button> }\n}\n```\n\n## Fixed Code:", "output": "use yew::prelude::*;\n\n#[function_component(Button)]\nfn button() -> Html {\n    let count = use_state(|| 0);\n    let onclick = {\n        let count = count.clone();\n        Callback::from(move |_| {\n            count.set(*count + 1);\n        })\n    };\n    html! { <button {onclick}>{\"Click\"}</button> }\n}", "task_id": "yew_002", "domain": "yew_wasm"}
{"instruction": "You are a Yew/WASM expert. Fix the following Yew frontend component code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse yew::prelude::*;\n\nstruct ButtonProps {\n    label: String,\n}\n\n#[function_component(Button)]\nfn button(props: &ButtonProps) -> Html {\n    html! { <button>{&props.label}</button> }\n}\n```\n\n## Fixed Code:", "output": "use yew::prelude::*;\n\n#[derive(Properties, PartialEq)]\nstruct ButtonProps {\n    label: String,\n}\n\n#[function_component(Button)]\nfn button(props: &ButtonProps) -> Html {\n    html! { <button>{&props.label}</button> }\n}", "task_id": "yew_003", "domain": "yew_wasm"}
{"instruction": "You are a Yew/WASM expert. Fix the following Yew frontend component code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse yew::prelude::*;\n\n#[function_component(Logger)]\nfn logger() -> Html {\n    let count = use_state(|| 0);\n    use_effect(|| {\n        log::info!(\"Count changed: {}\", *count);\n    });\n    html! { <div>{*count}</div> }\n}\n```\n\n## Fixed Code:", "output": "use yew::prelude::*;\n\n#[function_component(Logger)]\nfn logger() -> Html {\n    let count = use_state(|| 0);\n    {\n        let count = count.clone();\n        use_effect_with(count.clone(), move |count| {\n            log::info!(\"Count changed: {}\", **count);\n            || ()\n        });\n    }\n    html! { <div>{*count}</div> }\n}", "task_id": "yew_004", "domain": "yew_wasm"}
{"instruction": "You are an Axum REST API expert. Fix the following server handler code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse axum::{routing::get, Router};\n\nasync fn hello() {\n    \"Hello, World!\"\n}\n\nfn app() -> Router {\n    Router::new().route(\"/\", get(hello))\n}\n```\n\n## Fixed Code:", "output": "use axum::{routing::get, Router};\n\nasync fn hello() -> &'static str {\n    \"Hello, World!\"\n}\n\nfn app() -> Router {\n    Router::new().route(\"/\", get(hello))\n}", "task_id": "axum_001", "domain": "axum_server"}
{"instruction": "You are an Axum REST API expert. Fix the following server handler code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse axum::{routing::post, Router, Json};\nuse serde::Deserialize;\n\nstruct CreateUser {\n    name: String,\n}\n\nasync fn create_user(user: Json<CreateUser>) -> String {\n    format!(\"Created user: {}\", user.name)\n}\n```\n\n## Fixed Code:", "output": "use axum::{routing::post, Router, Json};\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct CreateUser {\n    name: String,\n}\n\nasync fn create_user(Json(user): Json<CreateUser>) -> String {\n    format!(\"Created user: {}\", user.name)\n}", "task_id": "axum_002", "domain": "axum_server"}
{"instruction": "You are an Axum REST API expert. Fix the following server handler code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse axum::{routing::get, Router, extract::State};\nuse std::sync::Arc;\n\nstruct AppState {\n    db: String,\n}\n\nasync fn handler(state: AppState) -> String {\n    format!(\"DB: {}\", state.db)\n}\n\nfn app() -> Router {\n    let state = Arc::new(AppState { db: \"postgres\".into() });\n    Router::new().route(\"/\", get(handler)).with_state(state)\n}\n```\n\n## Fixed Code:", "output": "use axum::{routing::get, Router, extract::State};\nuse std::sync::Arc;\n\nstruct AppState {\n    db: String,\n}\n\nasync fn handler(State(state): State<Arc<AppState>>) -> String {\n    format!(\"DB: {}\", state.db)\n}\n\nfn app() -> Router {\n    let state = Arc::new(AppState { db: \"postgres\".into() });\n    Router::new().route(\"/\", get(handler)).with_state(state)\n}", "task_id": "axum_003", "domain": "axum_server"}
{"instruction": "You are an Axum REST API expert. Fix the following server handler code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse axum::{routing::get, Router, http::StatusCode};\n\nasync fn might_fail() -> Result<String, String> {\n    Err(\"Something went wrong\".into())\n}\n\nasync fn handler() -> String {\n    might_fail().await?\n}\n```\n\n## Fixed Code:", "output": "use axum::{routing::get, Router, http::StatusCode, response::IntoResponse};\n\nasync fn might_fail() -> Result<String, String> {\n    Err(\"Something went wrong\".into())\n}\n\nasync fn handler() -> Result<String, (StatusCode, String)> {\n    might_fail().await.map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e))\n}", "task_id": "axum_004", "domain": "axum_server"}
{"instruction": "You are a SQLx database expert. Fix the following database code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse sqlx::PgPool;\n\nasync fn get_user(pool: &PgPool, id: i32) -> Result<String, sqlx::Error> {\n    let row = sqlx::query(\"SELECT name FROM users WHERE id = $1\")\n        .bind(id)\n        .fetch_one(pool)\n        .await?;\n    Ok(row.name)\n}\n```\n\n## Fixed Code:", "output": "use sqlx::PgPool;\n\nasync fn get_user(pool: &PgPool, id: i32) -> Result<String, sqlx::Error> {\n    let row = sqlx::query!(\"SELECT name FROM users WHERE id = $1\", id)\n        .fetch_one(pool)\n        .await?;\n    Ok(row.name)\n}", "task_id": "sqlx_001", "domain": "sqlx_db"}
{"instruction": "You are a SQLx database expert. Fix the following database code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse sqlx::PgPool;\n\nstruct User {\n    id: i32,\n    name: String,\n}\n\nasync fn get_users(pool: &PgPool) -> Result<Vec<User>, sqlx::Error> {\n    sqlx::query_as(\"SELECT id, name FROM users\")\n        .fetch_all(pool)\n        .await\n}\n```\n\n## Fixed Code:", "output": "use sqlx::{PgPool, FromRow};\n\n#[derive(FromRow)]\nstruct User {\n    id: i32,\n    name: String,\n}\n\nasync fn get_users(pool: &PgPool) -> Result<Vec<User>, sqlx::Error> {\n    sqlx::query_as(\"SELECT id, name FROM users\")\n        .fetch_all(pool)\n        .await\n}", "task_id": "sqlx_002", "domain": "sqlx_db"}
{"instruction": "You are a SQLx database expert. Fix the following database code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse sqlx::PgPool;\n\nasync fn transfer(pool: &PgPool, from: i32, to: i32, amount: i32) -> Result<(), sqlx::Error> {\n    sqlx::query!(\"UPDATE accounts SET balance = balance - $1 WHERE id = $2\", amount, from)\n        .execute(pool)\n        .await?;\n    sqlx::query!(\"UPDATE accounts SET balance = balance + $1 WHERE id = $2\", amount, to)\n        .execute(pool)\n        .await?;\n    Ok(())\n}\n```\n\n## Fixed Code:", "output": "use sqlx::PgPool;\n\nasync fn transfer(pool: &PgPool, from: i32, to: i32, amount: i32) -> Result<(), sqlx::Error> {\n    let mut tx = pool.begin().await?;\n    sqlx::query!(\"UPDATE accounts SET balance = balance - $1 WHERE id = $2\", amount, from)\n        .execute(&mut *tx)\n        .await?;\n    sqlx::query!(\"UPDATE accounts SET balance = balance + $1 WHERE id = $2\", amount, to)\n        .execute(&mut *tx)\n        .await?;\n    tx.commit().await?;\n    Ok(())\n}", "task_id": "sqlx_003", "domain": "sqlx_db"}
{"instruction": "You are a CLI development expert using clap. Fix the following CLI code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse clap::Parser;\n\nstruct Args {\n    #[arg(short, long)]\n    name: String,\n}\n\nfn main() {\n    let args = Args::parse();\n    println!(\"Hello, {}!\", args.name);\n}\n```\n\n## Fixed Code:", "output": "use clap::Parser;\n\n#[derive(Parser)]\nstruct Args {\n    #[arg(short, long)]\n    name: String,\n}\n\nfn main() {\n    let args = Args::parse();\n    println!(\"Hello, {}!\", args.name);\n}", "task_id": "cli_001", "domain": "cli_clap"}
{"instruction": "You are a CLI development expert using clap. Fix the following CLI code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\nenum Commands {\n    Add { name: String },\n    Remove { id: i32 },\n}\n```\n\n## Fixed Code:", "output": "use clap::{Parser, Subcommand};\n\n#[derive(Parser)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Add { name: String },\n    Remove { id: i32 },\n}", "task_id": "cli_002", "domain": "cli_clap"}
{"instruction": "You are a CLI development expert using clap. Fix the following CLI code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\nstruct Args {\n    #[arg(short, long)]\n    config: Option<String>,\n}\n\nfn main() {\n    let args = Args::parse();\n    let config = args.config.unwrap();  // May panic\n    println!(\"Config: {}\", config);\n}\n```\n\n## Fixed Code:", "output": "use clap::Parser;\n\n#[derive(Parser)]\nstruct Args {\n    #[arg(short, long)]\n    config: Option<String>,\n}\n\nfn main() {\n    let args = Args::parse();\n    let config = args.config.unwrap_or_else(|| \"default.toml\".to_string());\n    println!(\"Config: {}\", config);\n}", "task_id": "cli_003", "domain": "cli_clap"}
{"instruction": "You are a Rust refactoring expert. Improve the following code structure.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nfn process_users(users: Vec<User>) {\n    for user in &users {\n        println!(\"Processing: {}\", user.name);\n        if user.age > 18 {\n            println!(\"Adult: {}\", user.name);\n        }\n    }\n\n    for user in &users {\n        println!(\"Processing: {}\", user.name);\n        if user.age > 65 {\n            println!(\"Senior: {}\", user.name);\n        }\n    }\n}\n```\n\n## Fixed Code:", "output": "fn log_user(user: &User) {\n    println!(\"Processing: {}\", user.name);\n}\n\nfn process_users(users: Vec<User>) {\n    for user in &users {\n        log_user(user);\n        if user.age > 18 {\n            println!(\"Adult: {}\", user.name);\n        }\n    }\n\n    for user in &users {\n        log_user(user);\n        if user.age > 65 {\n            println!(\"Senior: {}\", user.name);\n        }\n    }\n}", "task_id": "refactor_001", "domain": "refactoring"}
{"instruction": "You are a Rust refactoring expert. Improve the following code structure.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nfn sum_even(numbers: &[i32]) -> i32 {\n    let mut sum = 0;\n    for n in numbers {\n        if n % 2 == 0 {\n            sum += n;\n        }\n    }\n    sum\n}\n```\n\n## Fixed Code:", "output": "fn sum_even(numbers: &[i32]) -> i32 {\n    numbers.iter().filter(|n| *n % 2 == 0).sum()\n}", "task_id": "refactor_002", "domain": "refactoring"}
{"instruction": "You are a Rust refactoring expert. Improve the following code structure.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nfn get_user_email(id: i32) -> Option<String> {\n    match get_user(id) {\n        Some(user) => {\n            match user.email {\n                Some(email) => Some(email),\n                None => None,\n            }\n        }\n        None => None,\n    }\n}\n```\n\n## Fixed Code:", "output": "fn get_user_email(id: i32) -> Option<String> {\n    get_user(id).and_then(|user| user.email)\n}", "task_id": "refactor_003", "domain": "refactoring"}
{"instruction": "You are a Rust code quality expert. Apply coding conventions to improve this code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nfn process_order(order: Order) -> Result<(), Error> {\n    // Validate order (too much in one function)\n    if order.items.is_empty() {\n        return Err(Error::EmptyOrder);\n    }\n    if order.total < 0.0 {\n        return Err(Error::InvalidTotal);\n    }\n\n    // Calculate tax\n    let tax = order.total * 0.08;\n    let total_with_tax = order.total + tax;\n\n    // Apply discount\n    let discount = if total_with_tax > 100.0 { 0.1 } else { 0.0 };\n    let final_total = total_with_tax * (1.0 - discount);\n\n    // Save to database\n    db::save_order(&order, final_total)?;\n\n    // Send confirmation\n    email::send_confirmation(&order.customer, final_total)?;\n\n    Ok(())\n}\n```\n\n## Fixed Code:", "output": "fn validate_order(order: &Order) -> Result<(), Error> {\n    if order.items.is_empty() {\n        return Err(Error::EmptyOrder);\n    }\n    if order.total < 0.0 {\n        return Err(Error::InvalidTotal);\n    }\n    Ok(())\n}\n\nfn calculate_total(order: &Order) -> f64 {\n    let tax = order.total * 0.08;\n    let total_with_tax = order.total + tax;\n    let discount = if total_with_tax > 100.0 { 0.1 } else { 0.0 };\n    total_with_tax * (1.0 - discount)\n}\n\nfn process_order(order: Order) -> Result<(), Error> {\n    validate_order(&order)?;\n    let final_total = calculate_total(&order);\n    db::save_order(&order, final_total)?;\n    email::send_confirmation(&order.customer, final_total)?;\n    Ok(())\n}", "task_id": "style_001", "domain": "style_metrics"}
{"instruction": "You are a Rust code quality expert. Apply coding conventions to improve this code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\n// lib.rs with 15+ functions - violates Module Function Count rule\npub fn create_user() { }\npub fn get_user() { }\npub fn update_user() { }\npub fn delete_user() { }\npub fn list_users() { }\npub fn create_post() { }\npub fn get_post() { }\npub fn update_post() { }\npub fn delete_post() { }\npub fn list_posts() { }\npub fn create_comment() { }\npub fn get_comment() { }\n```\n\n## Fixed Code:", "output": "// lib.rs - organized into submodules\npub mod users;\npub mod posts;\npub mod comments;\n\n// users.rs (max 7 functions)\npub fn create() { }\npub fn get() { }\npub fn update() { }\npub fn delete() { }\npub fn list() { }\n\n// posts.rs (max 7 functions)\npub fn create() { }\npub fn get() { }\npub fn update() { }\npub fn delete() { }\npub fn list() { }\n\n// comments.rs\npub fn create() { }\npub fn get() { }", "task_id": "style_002", "domain": "style_metrics"}
{"instruction": "You are a Rust code quality expert. Apply coding conventions to improve this code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(name = \"mytool\", version, about = \"A CLI tool\")]\nstruct Cli {\n    #[arg(short, long)]\n    verbose: bool,\n}\n```\n\n## Fixed Code:", "output": "use clap::Parser;\n\n/// A CLI tool\n///\n/// # AI CODING AGENT INSTRUCTIONS\n///\n/// This tool processes files. When using as an AI agent:\n/// - Use --verbose for detailed output\n/// - Exit codes: 0 = success, 1 = error\n/// - Output is JSON when --json flag is set\n#[derive(Parser)]\n#[command(name = \"mytool\", version, about, long_about = None)]\nstruct Cli {\n    #[arg(short, long)]\n    verbose: bool,\n}", "task_id": "style_003", "domain": "style_metrics"}
{"instruction": "You are a Rust code quality expert. Apply coding conventions to improve this code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(name = \"mytool\", version)]\nstruct Cli { }\n```\n\n## Fixed Code:", "output": "use clap::Parser;\n\nconst VERSION_INFO: &str = concat!(\n    env!(\"CARGO_PKG_VERSION\"),\n    \"\\nCopyright: 2024 Example Corp\",\n    \"\\nLicense: MIT\",\n    \"\\nRepository: https://github.com/example/mytool\",\n    \"\\nBuild Host: \", env!(\"VERGEN_SYSINFO_NAME\"),\n    \"\\nBuild Commit: \", env!(\"VERGEN_GIT_SHA\"),\n    \"\\nBuild Time: \", env!(\"VERGEN_BUILD_TIMESTAMP\"),\n);\n\n#[derive(Parser)]\n#[command(name = \"mytool\", version = VERSION_INFO)]\nstruct Cli { }", "task_id": "style_004", "domain": "style_metrics"}
{"instruction": "You are a Rust code quality expert. Apply coding conventions to improve this code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\n#[derive(Parser)]\n#[command(name = \"mytool\")]\nstruct Cli {\n    /// Enable verbose output\n    #[arg(short, long)]\n    verbose: bool,\n}\n```\n\n## Fixed Code:", "output": "#[derive(Parser)]\n#[command(name = \"mytool\")]\nstruct Cli {\n    /// Enable verbose output\n    ///\n    /// When enabled, the tool will print detailed progress information\n    /// including file paths, processing times, and intermediate results.\n    /// Useful for debugging and understanding tool behavior.\n    #[arg(short, long, help = \"Enable verbose output\")]\n    verbose: bool,\n}", "task_id": "style_005", "domain": "style_metrics"}
{"instruction": "You are a Rust code quality expert. Apply coding conventions to improve this code.\nReturn ONLY the fixed Rust code without explanation.", "input": "## Code:\n```rust\n// main.rs - 700+ lines with multiple concerns\nmod config { /* 100 lines */ }\nmod database { /* 200 lines */ }\nmod handlers { /* 300 lines */ }\nmod utils { /* 100 lines */ }\nfn main() { }\n```\n\n## Fixed Code:", "output": "// main.rs - only entry point\nmod config;\nmod database;\nmod handlers;\nmod utils;\n\nfn main() { }\n\n// config.rs - separate file\n// database.rs - separate file\n// handlers.rs - separate file\n// utils.rs - separate file", "task_id": "style_006", "domain": "style_metrics"}
