{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "fn get_name(names: &[String]) -> &str {\n    match names.first() {\n        Some(ref name) => name.as_str(),\n        None => \"unknown\",\n    }\n}\n\nfn main() {\n    let names = vec![\"Alice\".to_string(), \"Bob\".to_string()];\n    println!(\"{}\", get_name(&names));\n}", "output": "fn get_name(names: &[String]) -> &str {\n    match names.first() {\n        Some(name) => name.as_str(),\n        None => \"unknown\",\n    }\n}\n\nfn main() {\n    let names = vec![\"Alice\".to_string(), \"Bob\".to_string()];\n    println!(\"{}\", get_name(&names));\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "fn process_values(data: &Vec<(String, i32)>) {\n    for &(ref key, value) in data {\n        println!(\"{}: {}\", key, value);\n    }\n}\n\nfn main() {\n    let data = vec![(\"a\".to_string(), 1), (\"b\".to_string(), 2)];\n    process_values(&data);\n}", "output": "fn process_values(data: &Vec<(String, i32)>) {\n    for (key, value) in data {\n        println!(\"{}: {}\", key, value);\n    }\n}\n\nfn main() {\n    let data = vec![(\"a\".to_string(), 1), (\"b\".to_string(), 2)];\n    process_values(&data);\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "fn find_max(values: &[i32]) -> Option<i32> {\n    let mut max = None;\n    for &ref val in values {\n        match max {\n            Some(ref current) if current >= val => {}\n            _ => max = Some(*val),\n        }\n    }\n    max\n}\n\nfn main() {\n    let nums = vec![3, 1, 4, 1, 5, 9];\n    println!(\"{:?}\", find_max(&nums));\n}", "output": "fn find_max(values: &[i32]) -> Option<i32> {\n    let mut max = None;\n    for val in values {\n        match max {\n            Some(current) if current >= *val => {}\n            _ => max = Some(*val),\n        }\n    }\n    max\n}\n\nfn main() {\n    let nums = vec![3, 1, 4, 1, 5, 9];\n    println!(\"{:?}\", find_max(&nums));\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "use std::collections::HashMap;\n\nfn get_or_default<'a>(map: &'a HashMap<String, String>, key: &str) -> &'a str {\n    match map.get(key) {\n        Some(ref value) => value.as_str(),\n        None => \"default\",\n    }\n}\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"key\".to_string(), \"value\".to_string());\n    println!(\"{}\", get_or_default(&map, \"key\"));\n}", "output": "use std::collections::HashMap;\n\nfn get_or_default<'a>(map: &'a HashMap<String, String>, key: &str) -> &'a str {\n    match map.get(key) {\n        Some(value) => value.as_str(),\n        None => \"default\",\n    }\n}\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"key\".to_string(), \"value\".to_string());\n    println!(\"{}\", get_or_default(&map, \"key\"));\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "enum Command {\n    Move { x: i32, y: i32 },\n    Print(String),\n    Quit,\n}\n\nfn handle(cmd: &Command) {\n    match cmd {\n        Command::Move { ref x, ref y } => println!(\"Moving to ({}, {})\", x, y),\n        Command::Print(ref msg) => println!(\"{}\", msg),\n        Command::Quit => println!(\"Quitting\"),\n    }\n}\n\nfn main() {\n    handle(&Command::Print(\"hello\".to_string()));\n}", "output": "enum Command {\n    Move { x: i32, y: i32 },\n    Print(String),\n    Quit,\n}\n\nfn handle(cmd: &Command) {\n    match cmd {\n        Command::Move { x, y } => println!(\"Moving to ({}, {})\", x, y),\n        Command::Print(msg) => println!(\"{}\", msg),\n        Command::Quit => println!(\"Quitting\"),\n    }\n}\n\nfn main() {\n    handle(&Command::Print(\"hello\".to_string()));\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "extern \"C\" {\n    fn abs(input: i32) -> i32;\n    fn strlen(s: *const u8) -> usize;\n}\n\nfn main() {\n    let result = unsafe { abs(-42) };\n    println!(\"abs(-42) = {}\", result);\n}", "output": "unsafe extern \"C\" {\n    fn abs(input: i32) -> i32;\n    fn strlen(s: *const u8) -> usize;\n}\n\nfn main() {\n    let result = unsafe { abs(-42) };\n    println!(\"abs(-42) = {}\", result);\n}", "pattern": "unsafe_extern_block", "error_hint": "extern blocks must be unsafe"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "extern \"C\" {\n    fn malloc(size: usize) -> *mut u8;\n    fn free(ptr: *mut u8);\n    fn memcpy(dest: *mut u8, src: *const u8, n: usize) -> *mut u8;\n}\n\nfn main() {\n    unsafe {\n        let ptr = malloc(256);\n        if !ptr.is_null() {\n            free(ptr);\n        }\n    }\n}", "output": "unsafe extern \"C\" {\n    fn malloc(size: usize) -> *mut u8;\n    fn free(ptr: *mut u8);\n    fn memcpy(dest: *mut u8, src: *const u8, n: usize) -> *mut u8;\n}\n\nfn main() {\n    unsafe {\n        let ptr = malloc(256);\n        if !ptr.is_null() {\n            free(ptr);\n        }\n    }\n}", "pattern": "unsafe_extern_block", "error_hint": "extern blocks must be unsafe"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "extern \"C\" {\n    fn getenv(name: *const i8) -> *const i8;\n}\n\nextern \"C\" fn callback(x: i32) -> i32 {\n    x * 2\n}\n\nfn main() {\n    println!(\"callback(21) = {}\", callback(21));\n}", "output": "unsafe extern \"C\" {\n    fn getenv(name: *const i8) -> *const i8;\n}\n\nextern \"C\" fn callback(x: i32) -> i32 {\n    x * 2\n}\n\nfn main() {\n    println!(\"callback(21) = {}\", callback(21));\n}", "pattern": "unsafe_extern_block", "error_hint": "extern blocks must be unsafe"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "extern \"C\" {\n    fn abs(input: i32) -> i32;\n    fn strlen(s: *const u8) -> usize;\n}\n\nfn main() {\n    let result = unsafe { abs(-42) };\n    println!(\"abs(-42) = {}\", result);\n}", "output": "unsafe extern \"C\" {\n    fn abs(input: i32) -> i32;\n    fn strlen(s: *const u8) -> usize;\n}\n\nfn main() {\n    let result = unsafe { abs(-42) };\n    println!(\"abs(-42) = {}\", result);\n}", "pattern": "unsafe_extern_block", "error_hint": "extern blocks must be unsafe"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "extern \"C\" {\n    fn malloc(size: usize) -> *mut u8;\n    fn free(ptr: *mut u8);\n    fn memcpy(dest: *mut u8, src: *const u8, n: usize) -> *mut u8;\n}\n\nfn main() {\n    unsafe {\n        let ptr = malloc(256);\n        if !ptr.is_null() {\n            free(ptr);\n        }\n    }\n}", "output": "unsafe extern \"C\" {\n    fn malloc(size: usize) -> *mut u8;\n    fn free(ptr: *mut u8);\n    fn memcpy(dest: *mut u8, src: *const u8, n: usize) -> *mut u8;\n}\n\nfn main() {\n    unsafe {\n        let ptr = malloc(256);\n        if !ptr.is_null() {\n            free(ptr);\n        }\n    }\n}", "pattern": "unsafe_extern_block", "error_hint": "extern blocks must be unsafe"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "extern \"C\" {\n    fn getenv(name: *const i8) -> *const i8;\n}\n\nextern \"C\" fn callback(x: i32) -> i32 {\n    x * 2\n}\n\nfn main() {\n    println!(\"callback(21) = {}\", callback(21));\n}", "output": "unsafe extern \"C\" {\n    fn getenv(name: *const i8) -> *const i8;\n}\n\nextern \"C\" fn callback(x: i32) -> i32 {\n    x * 2\n}\n\nfn main() {\n    println!(\"callback(21) = {}\", callback(21));\n}", "pattern": "unsafe_extern_block", "error_hint": "extern blocks must be unsafe"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "#[no_mangle]\npub extern \"C\" fn rust_multiply(a: i32, b: i32) -> i32 {\n    a * b\n}\n\nfn main() {\n    println!(\"{}\", rust_multiply(6, 7));\n}", "output": "#[unsafe(no_mangle)]\npub extern \"C\" fn rust_multiply(a: i32, b: i32) -> i32 {\n    a * b\n}\n\nfn main() {\n    println!(\"{}\", rust_multiply(6, 7));\n}", "pattern": "unsafe_attributes", "error_hint": "unsafe attribute used without unsafe"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "#[export_name = \"custom_add\"]\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[link_section = \".custom_data\"]\npub static VERSION: u32 = 1;\n\nfn main() {\n    println!(\"{}\", add(1, 2));\n}", "output": "#[unsafe(export_name = \"custom_add\")]\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[unsafe(link_section = \".custom_data\")]\npub static VERSION: u32 = 1;\n\nfn main() {\n    println!(\"{}\", add(1, 2));\n}", "pattern": "unsafe_attributes", "error_hint": "unsafe attribute used without unsafe"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "use std::env;\n\nfn setup_environment() {\n    env::set_var(\"RUST_LOG\", \"debug\");\n    env::set_var(\"APP_MODE\", \"development\");\n}\n\nfn main() {\n    setup_environment();\n    println!(\"RUST_LOG={}\", env::var(\"RUST_LOG\").unwrap_or_default());\n}", "output": "use std::env;\n\nfn setup_environment() {\n    unsafe {\n        env::set_var(\"RUST_LOG\", \"debug\");\n        env::set_var(\"APP_MODE\", \"development\");\n    }\n}\n\nfn main() {\n    setup_environment();\n    println!(\"RUST_LOG={}\", env::var(\"RUST_LOG\").unwrap_or_default());\n}", "pattern": "env_var_unsafe", "error_hint": "call to unsafe function `std::env::set_var` is unsafe and requires unsafe block"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "fn main() {\n    std::env::set_var(\"MY_VAR\", \"hello\");\n    let val = std::env::var(\"MY_VAR\").unwrap();\n    println!(\"{}\", val);\n    std::env::remove_var(\"MY_VAR\");\n}", "output": "fn main() {\n    unsafe {\n        std::env::set_var(\"MY_VAR\", \"hello\");\n    }\n    let val = std::env::var(\"MY_VAR\").unwrap();\n    println!(\"{}\", val);\n    unsafe {\n        std::env::remove_var(\"MY_VAR\");\n    }\n}", "pattern": "env_var_unsafe", "error_hint": "call to unsafe function `std::env::set_var` is unsafe and requires unsafe block"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn setup() {\n        std::env::set_var(\"TEST_DB_URL\", \"sqlite::memory:\");\n    }\n\n    fn teardown() {\n        std::env::remove_var(\"TEST_DB_URL\");\n    }\n\n    #[test]\n    fn test_connection() {\n        setup();\n        let url = std::env::var(\"TEST_DB_URL\").unwrap();\n        assert_eq!(url, \"sqlite::memory:\");\n        teardown();\n    }\n}\n\nfn main() {}", "output": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn setup() {\n        unsafe {\n            std::env::set_var(\"TEST_DB_URL\", \"sqlite::memory:\");\n        }\n    }\n\n    fn teardown() {\n        unsafe {\n            std::env::remove_var(\"TEST_DB_URL\");\n        }\n    }\n\n    #[test]\n    fn test_connection() {\n        setup();\n        let url = std::env::var(\"TEST_DB_URL\").unwrap();\n        assert_eq!(url, \"sqlite::memory:\");\n        teardown();\n    }\n}\n\nfn main() {}", "pattern": "env_var_unsafe", "error_hint": "call to unsafe function `std::env::set_var` is unsafe and requires unsafe block"}
{"instruction": "Fix the Rust 2024 edition compilation warning (treated as error).", "input": "unsafe fn get_unchecked(slice: &[i32], index: usize) -> i32 {\n    *slice.get_unchecked(index)\n}\n\nfn main() {\n    let data = [10, 20, 30, 40, 50];\n    let val = unsafe { get_unchecked(&data, 2) };\n    println!(\"{}\", val);\n}", "output": "unsafe fn get_unchecked(slice: &[i32], index: usize) -> i32 {\n    unsafe { *slice.get_unchecked(index) }\n}\n\nfn main() {\n    let data = [10, 20, 30, 40, 50];\n    let val = unsafe { get_unchecked(&data, 2) };\n    println!(\"{}\", val);\n}", "pattern": "unsafe_op_in_unsafe_fn", "error_hint": "call to unsafe function is unsafe and requires unsafe block"}
{"instruction": "Fix the Rust 2024 edition compilation warning (treated as error).", "input": "use std::ptr;\n\nunsafe fn swap_raw<T>(a: *mut T, b: *mut T) {\n    let tmp = ptr::read(a);\n    ptr::write(a, ptr::read(b));\n    ptr::write(b, tmp);\n}\n\nfn main() {\n    let mut x = 1;\n    let mut y = 2;\n    unsafe { swap_raw(&mut x, &mut y) };\n    println!(\"x={}, y={}\", x, y);\n}", "output": "use std::ptr;\n\nunsafe fn swap_raw<T>(a: *mut T, b: *mut T) {\n    unsafe {\n        let tmp = ptr::read(a);\n        ptr::write(a, ptr::read(b));\n        ptr::write(b, tmp);\n    }\n}\n\nfn main() {\n    let mut x = 1;\n    let mut y = 2;\n    unsafe { swap_raw(&mut x, &mut y) };\n    println!(\"x={}, y={}\", x, y);\n}", "pattern": "unsafe_op_in_unsafe_fn", "error_hint": "call to unsafe function is unsafe and requires unsafe block"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "fn main() {\n    let gen = 42;\n    println!(\"Generation: {}\", gen);\n}", "output": "fn main() {\n    let generation = 42;\n    println!(\"Generation: {}\", generation);\n}", "pattern": "gen_keyword_reserved", "error_hint": "expected identifier, found keyword `gen`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "struct Config {\n    gen: u32,\n    name: String,\n}\n\nfn main() {\n    let config = Config { gen: 1, name: \"test\".to_string() };\n    println!(\"Gen {}: {}\", config.gen, config.name);\n}", "output": "struct Config {\n    generation: u32,\n    name: String,\n}\n\nfn main() {\n    let config = Config { generation: 1, name: \"test\".to_string() };\n    println!(\"Gen {}: {}\", config.generation, config.name);\n}", "pattern": "gen_keyword_reserved", "error_hint": "expected identifier, found keyword `gen`"}
{"instruction": "Refactor this Rust code to use let chains (Rust 2024 idiom).", "input": "fn process(a: Option<i32>, b: Option<i32>) -> Option<i32> {\n    if let Some(x) = a {\n        if let Some(y) = b {\n            if x > 0 && y > 0 {\n                return Some(x + y);\n            }\n        }\n    }\n    None\n}\n\nfn main() {\n    println!(\"{:?}\", process(Some(3), Some(4)));\n    println!(\"{:?}\", process(Some(-1), Some(4)));\n    println!(\"{:?}\", process(None, Some(4)));\n}", "output": "fn process(a: Option<i32>, b: Option<i32>) -> Option<i32> {\n    if let Some(x) = a && let Some(y) = b && x > 0 && y > 0 {\n        return Some(x + y);\n    }\n    None\n}\n\nfn main() {\n    println!(\"{:?}\", process(Some(3), Some(4)));\n    println!(\"{:?}\", process(Some(-1), Some(4)));\n    println!(\"{:?}\", process(None, Some(4)));\n}", "pattern": "let_chains", "error_hint": "Nested if-let can be simplified with let chains in Rust 2024"}
{"instruction": "Refactor this Rust code to use let chains (Rust 2024 idiom).", "input": "use std::collections::HashMap;\n\nfn lookup(map: &HashMap<String, Vec<String>>, key: &str, idx: usize) -> Option<String> {\n    if let Some(values) = map.get(key) {\n        if let Some(item) = values.get(idx) {\n            if !item.is_empty() {\n                return Some(item.clone());\n            }\n        }\n    }\n    None\n}\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"greetings\".to_string(), vec![\"hello\".to_string(), \"hi\".to_string()]);\n    println!(\"{:?}\", lookup(&map, \"greetings\", 0));\n}", "output": "use std::collections::HashMap;\n\nfn lookup(map: &HashMap<String, Vec<String>>, key: &str, idx: usize) -> Option<String> {\n    if let Some(values) = map.get(key) && let Some(item) = values.get(idx) && !item.is_empty() {\n        return Some(item.clone());\n    }\n    None\n}\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"greetings\".to_string(), vec![\"hello\".to_string(), \"hi\".to_string()]);\n    println!(\"{:?}\", lookup(&map, \"greetings\", 0));\n}", "pattern": "let_chains", "error_hint": "Nested if-let can be simplified with let chains in Rust 2024"}
{"instruction": "Refactor this Rust function to be under 50 lines (sw-checklist requirement).", "input": "fn process_records(records: Vec<Record>) -> Result<Summary, Error> {\n    let mut total = 0;\n    let mut count = 0;\n    let mut errors = Vec::new();\n    let mut warnings = Vec::new();\n    let mut by_category: HashMap<String, Vec<Record>> = HashMap::new();\n\n    for record in &records {\n        if record.value < 0 {\n            errors.push(format!(\"Negative value in record {}\", record.id));\n            continue;\n        }\n        if record.value == 0 {\n            warnings.push(format!(\"Zero value in record {}\", record.id));\n        }\n        total += record.value;\n        count += 1;\n        by_category\n            .entry(record.category.clone())\n            .or_default()\n            .push(record.clone());\n    }\n\n    let average = if count > 0 { total / count } else { 0 };\n\n    let mut category_summaries = Vec::new();\n    for (cat, cat_records) in &by_category {\n        let cat_total: i64 = cat_records.iter().map(|r| r.value).sum();\n        let cat_avg = cat_total / cat_records.len() as i64;\n        let cat_max = cat_records.iter().map(|r| r.value).max().unwrap_or(0);\n        let cat_min = cat_records.iter().map(|r| r.value).min().unwrap_or(0);\n        category_summaries.push(CategorySummary {\n            name: cat.clone(),\n            count: cat_records.len(),\n            total: cat_total,\n            average: cat_avg,\n            max: cat_max,\n            min: cat_min,\n        });\n    }\n\n    category_summaries.sort_by(|a, b| b.total.cmp(&a.total));\n\n    if !errors.is_empty() {\n        return Err(Error::ValidationErrors(errors));\n    }\n\n    Ok(Summary {\n        total,\n        count,\n        average,\n        warnings,\n        categories: category_summaries,\n    })\n}", "output": "fn validate_records(records: &[Record]) -> Result<(), Vec<String>> {\n    let errors: Vec<String> = records\n        .iter()\n        .filter(|r| r.value < 0)\n        .map(|r| format!(\"Negative value in record {}\", r.id))\n        .collect();\n    if errors.is_empty() { Ok(()) } else { Err(errors) }\n}\n\nfn collect_warnings(records: &[Record]) -> Vec<String> {\n    records\n        .iter()\n        .filter(|r| r.value == 0)\n        .map(|r| format!(\"Zero value in record {}\", r.id))\n        .collect()\n}\n\nfn summarize_category(name: &str, records: &[Record]) -> CategorySummary {\n    let total: i64 = records.iter().map(|r| r.value).sum();\n    CategorySummary {\n        name: name.to_string(),\n        count: records.len(),\n        total,\n        average: total / records.len().max(1) as i64,\n        max: records.iter().map(|r| r.value).max().unwrap_or(0),\n        min: records.iter().map(|r| r.value).min().unwrap_or(0),\n    }\n}\n\nfn process_records(records: Vec<Record>) -> Result<Summary, Error> {\n    if let Err(errors) = validate_records(&records) {\n        return Err(Error::ValidationErrors(errors));\n    }\n\n    let valid: Vec<_> = records.iter().filter(|r| r.value >= 0).collect();\n    let total: i64 = valid.iter().map(|r| r.value).sum();\n    let count = valid.len();\n\n    let mut by_cat: HashMap<String, Vec<Record>> = HashMap::new();\n    for r in &valid {\n        by_cat.entry(r.category.clone()).or_default().push((*r).clone());\n    }\n\n    let mut categories: Vec<_> = by_cat\n        .iter()\n        .map(|(name, recs)| summarize_category(name, recs))\n        .collect();\n    categories.sort_by(|a, b| b.total.cmp(&a.total));\n\n    Ok(Summary {\n        total,\n        count,\n        average: if count > 0 { total / count as i64 } else { 0 },\n        warnings: collect_warnings(&records),\n        categories,\n    })\n}", "pattern": "function_loc_refactor", "error_hint": "Function has too many lines (max 50). Split into smaller focused functions."}
{"instruction": "This module has too many functions (max 7 per module). Refactor by splitting into submodules.", "input": "// lib.rs - 15 functions in one file\npub fn create_user() { /* ... */ }\npub fn delete_user() { /* ... */ }\npub fn update_user() { /* ... */ }\npub fn get_user() { /* ... */ }\npub fn list_users() { /* ... */ }\npub fn create_post() { /* ... */ }\npub fn delete_post() { /* ... */ }\npub fn update_post() { /* ... */ }\npub fn get_post() { /* ... */ }\npub fn list_posts() { /* ... */ }\npub fn create_comment() { /* ... */ }\npub fn delete_comment() { /* ... */ }\npub fn get_comment() { /* ... */ }\npub fn list_comments() { /* ... */ }\npub fn search() { /* ... */ }", "output": "// lib.rs - split into submodules\nmod users;\nmod posts;\nmod comments;\nmod search;\n\npub use users::{create_user, delete_user, update_user, get_user, list_users};\npub use posts::{create_post, delete_post, update_post, get_post, list_posts};\npub use comments::{create_comment, delete_comment, get_comment, list_comments};\npub use search::search;\n\n// users.rs\n// pub fn create_user() { /* ... */ }\n// pub fn delete_user() { /* ... */ }\n// pub fn update_user() { /* ... */ }\n// pub fn get_user() { /* ... */ }\n// pub fn list_users() { /* ... */ }\n\n// posts.rs\n// pub fn create_post() { /* ... */ }\n// ...etc", "pattern": "module_function_count", "error_hint": "Module has too many functions (max 7). Split into submodules."}
