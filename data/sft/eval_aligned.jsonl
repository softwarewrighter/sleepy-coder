{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt { if !s.is_empty() { return Some(s); } } None }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt && !s.is_empty() { return Some(s); } None }", "task_id": "rust_2024_let_chains_044", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_or_compute(opt: Option<i32>) -> i32 { opt.unwrap_or(expensive_default()) } fn expensive_default() -> i32 { 42 }\n```\n\n## Compiler Error:\nunnecessary eager evaluation: use unwrap_or_else for lazy default\n\n## Fixed Code:", "output": "fn get_or_compute(opt: Option<i32>) -> i32 { opt.unwrap_or_else(|| expensive_default()) } fn expensive_default() -> i32 { 42 }", "task_id": "result_handling_unwrap_or_else_062", "family": "result_handling", "pattern": "unwrap_or_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; let first = items.first(); println!(\"{}\", first); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let items = vec![1, 2, 3]; if let Some(first) = items.first() { println!(\"{}\", first); } }", "task_id": "result_handling_if_let_option_032", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", data); let _ = data; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let data = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", data); let _ = data.clone(); } }", "task_id": "borrow_checker_move_in_loop_092", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::rc::Rc; fn send_to_thread<T: Send>(val: T) {} fn main() { let rc = Rc::new(5); send_to_thread(rc); }\n```\n\n## Compiler Error:\n`Rc` cannot be sent between threads safely: use Arc instead\n\n## Fixed Code:", "output": "use std::sync::Arc; fn send_to_thread<T: Send>(val: T) {} fn main() { let rc = Arc::new(5); send_to_thread(rc); }", "task_id": "trait_bounds_rc_not_send_080", "family": "trait_bounds", "pattern": "rc_not_send"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#![allow(clippy::all)] fn add(a: i32, b: i32) -> i32 { let result: i32 = a + b; return result; }\n```\n\n## Compiler Error:\nnever use blanket #[allow(clippy::all)]: fix the specific issues instead\n\n## Fixed Code:", "output": "fn add(a: i32, b: i32) -> i32 { a + b }", "task_id": "clippy_suppression_no_blanket_suppress_025", "family": "clippy_suppression", "pattern": "no_blanket_suppress"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; let copy = nums; println!(\"{:?}\", nums); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let nums = vec![1, 2, 3]; let copy = nums.clone(); println!(\"{:?}\", nums); }", "task_id": "borrow_checker_use_after_move_clone_014", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![String::from(\"a\"), String::from(\"b\")]; let item = items[0]; }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn main() { let items = vec![String::from(\"a\"), String::from(\"b\")]; let item = items[0].clone(); }", "task_id": "borrow_checker_move_out_of_index_127", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; for _ in 0..2 { let _ = v; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let v = vec![1, 2, 3]; for _ in 0..2 { let _ = v.clone(); } }", "task_id": "borrow_checker_move_in_loop_093", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let n: i32 = \"42\".parse()?; println!(\"{}\", n); }\n```\n\n## Compiler Error:\nthe `?` operator in main needs `fn main() -> Result<...>`\n\n## Fixed Code:", "output": "fn main() -> Result<(), Box<dyn std::error::Error>> { let n: i32 = \"42\".parse()?; println!(\"{}\", n); Ok(()) }", "task_id": "result_handling_main_question_mark_024", "family": "result_handling", "pattern": "main_question_mark"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn find_item(v: &[i32], target: i32) -> Result<i32, &str> { v.iter().find(|&&x| x == target).copied() }\n```\n\n## Compiler Error:\nmismatched types: use ok_or to convert Option to Result\n\n## Fixed Code:", "output": "fn find_item(v: &[i32], target: i32) -> Result<i32, &str> { v.iter().find(|&&x| x == target).copied().ok_or(\"not found\") }", "task_id": "result_handling_option_ok_or_021", "family": "result_handling", "pattern": "option_ok_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; let copy = nums; println!(\"{:?}\", nums); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let nums = vec![1, 2, 3]; let copy = nums.clone(); println!(\"{:?}\", nums); }", "task_id": "borrow_checker_use_after_move_clone_011", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n// lib.rs with too many functions\npub fn create_user() {} pub fn get_user() {} pub fn update_user() {} pub fn delete_user() {} pub fn list_users() {} pub fn create_post() {} pub fn get_post() {} pub fn update_post() {} pub fn delete_post() {} pub fn list_posts() {} pub fn create_comment() {} pub fn get_comment() {}\n```\n\n## Compiler Error:\ntoo many functions in module: split into focused submodules\n\n## Fixed Code:", "output": "// lib.rs\npub mod users;\npub mod posts;\npub mod comments;\n\n// users.rs\npub fn create() {} pub fn get() {} pub fn update() {} pub fn delete() {} pub fn list() {}\n\n// posts.rs\npub fn create() {} pub fn get() {} pub fn update() {} pub fn delete() {} pub fn list() {}\n\n// comments.rs\npub fn create() {} pub fn get() {}", "task_id": "complexity_split_large_module_006", "family": "complexity", "pattern": "split_large_module"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn greet(who: &str) { println!(\"Hello, {}\", who); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn greet(who: &str) { println!(\"Hello, {who}\"); }", "task_id": "rust_2024_inline_format_args_005", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_first(v: &[&str]) -> Result<i32, &str> { v.first().map(|s| s.parse().unwrap()) }\n```\n\n## Compiler Error:\nmismatched types: use ok_or to convert Option to Result\n\n## Fixed Code:", "output": "fn parse_first(v: &[&str]) -> Result<i32, &str> { v.first().ok_or(\"empty\")?.parse().map_err(|_| \"parse error\") }", "task_id": "result_handling_option_ok_or_019", "family": "result_handling", "pattern": "option_ok_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Score { value: i32 } fn main() { let mut items = vec![Score { value: 3 }, Score { value: 1 }]; items.sort(); }\n```\n\n## Compiler Error:\nthe trait `Ord` is not implemented: add #[derive(PartialEq, Eq, PartialOrd, Ord)]\n\n## Fixed Code:", "output": "#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Score { value: i32 } fn main() { let mut items = vec![Score { value: 3 }, Score { value: 1 }]; items.sort(); }", "task_id": "trait_bounds_missing_ord_071", "family": "trait_bounds", "pattern": "missing_ord"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn make_vec() -> &Vec<i32> { let v = vec![1, 2, 3]; &v }\n```\n\n## Compiler Error:\ncannot return reference to local variable: return owned type instead\n\n## Fixed Code:", "output": "fn make_vec() -> Vec<i32> { vec![1, 2, 3] }", "task_id": "borrow_checker_return_local_ref_143", "family": "borrow_checker", "pattern": "return_local_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn is_ok(r: &Result<i32, &str>) -> bool { match r { Ok(_) => true, _ => false } }\n```\n\n## Compiler Error:\nclippy::match_like_matches_macro: use matches!() macro\n\n## Fixed Code:", "output": "fn is_ok(r: &Result<i32, &str>) -> bool { matches!(r, Ok(_)) }", "task_id": "rust_2024_use_matches_macro_031", "family": "rust_2024", "pattern": "use_matches_macro"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Item { count: usize } fn main() { let x = Item { count: 10 }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct Item { count: usize } fn main() { let x = Item { count: 10 }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_007", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::match_like_matches_macro)] fn is_vowel(c: char) -> bool { match c { 'a' | 'e' | 'i' | 'o' | 'u' => true, _ => false } }\n```\n\n## Compiler Error:\nclippy::match_like_matches_macro: use matches!() instead of suppressing\n\n## Fixed Code:", "output": "fn is_vowel(c: char) -> bool { matches!(c, 'a' | 'e' | 'i' | 'o' | 'u') }", "task_id": "clippy_suppression_no_suppress_matches_020", "family": "clippy_suppression", "pattern": "no_suppress_matches"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_or_default(s: &str) -> i32 { match s.parse() { Ok(n) => n, Err(_) => return -1 } }\n```\n\n## Compiler Error:\nuse let-else pattern for early returns on None/Err\n\n## Fixed Code:", "output": "fn parse_or_default(s: &str) -> i32 { let Ok(n) = s.parse() else { return -1; }; n }", "task_id": "rust_2024_let_else_050", "family": "rust_2024", "pattern": "let_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::needless_collect)] fn sum_doubled(v: &[i32]) -> i32 { let doubled: Vec<i32> = v.iter().map(|x| x * 2).collect(); doubled.into_iter().sum() }\n```\n\n## Compiler Error:\nclippy::needless_collect: remove the unnecessary .collect() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn sum_doubled(v: &[i32]) -> i32 { v.iter().map(|x| x * 2).sum() }", "task_id": "clippy_suppression_no_suppress_needless_collect_000", "family": "clippy_suppression", "pattern": "no_suppress_needless_collect"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = String::from(\"test\"); let backup = data; println!(\"{}\", data); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let data = String::from(\"test\"); let backup = data.clone(); println!(\"{}\", data); }", "task_id": "borrow_checker_use_after_move_clone_002", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; for _ in 0..2 { let _ = nums; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let nums = vec![1, 2, 3]; for _ in 0..2 { let _ = nums.clone(); } }", "task_id": "borrow_checker_move_in_loop_100", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; nums.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut nums = vec![1, 2, 3]; nums.push(4); }", "task_id": "borrow_checker_missing_mut_055", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let buf = String::new(); buf.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut buf = String::new(); buf.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_059", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::clone_on_ref_ptr)] fn share(a: &std::sync::Arc<String>) -> std::sync::Arc<String> { a.clone() }\n```\n\n## Compiler Error:\nclippy::clone_on_ref_ptr: use Arc::clone() for clarity instead of suppressing\n\n## Fixed Code:", "output": "fn share(a: &std::sync::Arc<String>) -> std::sync::Arc<String> { std::sync::Arc::clone(a) }", "task_id": "clippy_suppression_no_suppress_clone_ref_022", "family": "clippy_suppression", "pattern": "no_suppress_clone_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Vec2 { a: i32, b: i32 } fn main() { let a = Vec2 { a: 1, b: 2 }; let b = Vec2 { a: 1, b: 2 }; println!(\"{}\", a == b); }\n```\n\n## Compiler Error:\nbinary operation `==` cannot be applied: add #[derive(PartialEq)]\n\n## Fixed Code:", "output": "#[derive(PartialEq)] struct Vec2 { a: i32, b: i32 } fn main() { let a = Vec2 { a: 1, b: 2 }; let b = Vec2 { a: 1, b: 2 }; println!(\"{}\", a == b); }", "task_id": "trait_bounds_missing_partial_eq_054", "family": "trait_bounds", "pattern": "missing_partial_eq"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Amount { qty: i32 } fn double(n: Amount) -> i32 { n.qty * 2 } fn main() { let n = Amount { qty: 5 }; println!(\"{} {}\", double(n), double(n)); }\n```\n\n## Compiler Error:\nuse of moved value: add #[derive(Clone, Copy)]\n\n## Fixed Code:", "output": "#[derive(Clone, Copy)] struct Amount { qty: i32 } fn double(n: Amount) -> i32 { n.qty * 2 } fn main() { let n = Amount { qty: 5 }; println!(\"{} {}\", double(n), double(n)); }", "task_id": "trait_bounds_missing_copy_028", "family": "trait_bounds", "pattern": "missing_copy"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_or_make(opt: Option<String>) -> String { opt.unwrap_or(generate()) } fn generate() -> String { String::from(\"default\") }\n```\n\n## Compiler Error:\nunnecessary eager evaluation: use unwrap_or_else for lazy default\n\n## Fixed Code:", "output": "fn get_or_make(opt: Option<String>) -> String { opt.unwrap_or_else(generate) } fn generate() -> String { String::from(\"default\") }", "task_id": "result_handling_unwrap_or_else_065", "family": "result_handling", "pattern": "unwrap_or_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Label { value: String } fn main() { let m = Label { value: \"hello\".into() }; println!(\"{}\", m); }\n```\n\n## Compiler Error:\ndoesn't implement `std::fmt::Display`: implement Display trait\n\n## Fixed Code:", "output": "use std::fmt; struct Label { value: String } impl fmt::Display for Label { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"{}\", self.value) } } fn main() { let m = Label { value: \"hello\".into() }; println!(\"{}\", m); }", "task_id": "trait_bounds_missing_display_093", "family": "trait_bounds", "pattern": "missing_display"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Record { text: String } fn main() { let a = Record { text: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Record { text: String } fn main() { let a = Record { text: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_013", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn read_file(path: &str) -> String { std::fs::read_to_string(path)? }\n```\n\n## Compiler Error:\nthe `?` operator can only be used in a function that returns `Result`\n\n## Fixed Code:", "output": "fn read_file(path: &str) -> Result<String, std::io::Error> { Ok(std::fs::read_to_string(path)?) }", "task_id": "result_handling_question_mark_return_type_004", "family": "result_handling", "pattern": "question_mark_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Count { n: i32 } fn main() { let a = Count { n: 42 }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Count { n: i32 } fn main() { let a = Count { n: 42 }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_023", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::collections::HashMap; struct Tag { code: i32 } fn main() { let mut map = HashMap::new(); map.insert(Tag { code: 1 }, \"value\"); }\n```\n\n## Compiler Error:\nthe trait `Hash` is not implemented: add #[derive(Hash, PartialEq, Eq)]\n\n## Fixed Code:", "output": "use std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Tag { code: i32 } fn main() { let mut map = HashMap::new(); map.insert(Tag { code: 1 }, \"value\"); }", "task_id": "trait_bounds_missing_hash_066", "family": "trait_bounds", "pattern": "missing_hash"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Settings { retries: u32 } fn main() { let c: Settings = Default::default(); }\n```\n\n## Compiler Error:\ndoesn't implement `Default`: add #[derive(Default)]\n\n## Fixed Code:", "output": "#[derive(Default)] struct Settings { retries: u32 } fn main() { let c: Settings = Default::default(); }", "task_id": "trait_bounds_missing_default_051", "family": "trait_bounds", "pattern": "missing_default"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_first(v: &[&str]) -> Result<i32, &str> { v.first().map(|s| s.parse().unwrap()) }\n```\n\n## Compiler Error:\nmismatched types: use ok_or to convert Option to Result\n\n## Fixed Code:", "output": "fn parse_first(v: &[&str]) -> Result<i32, &str> { v.first().ok_or(\"empty\")?.parse().map_err(|_| \"parse error\") }", "task_id": "result_handling_option_ok_or_020", "family": "result_handling", "pattern": "option_ok_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn is_ok(r: &Result<i32, &str>) -> bool { match r { Ok(_) => true, _ => false } }\n```\n\n## Compiler Error:\nclippy::match_like_matches_macro: use matches!() macro\n\n## Fixed Code:", "output": "fn is_ok(r: &Result<i32, &str>) -> bool { matches!(r, Ok(_)) }", "task_id": "rust_2024_use_matches_macro_032", "family": "rust_2024", "pattern": "use_matches_macro"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut v = vec![\"a\".to_string(), \"b\".to_string()]; let snapshot = &v; v.push(\"c\".to_string()); println!(\"{:?}\", snapshot); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut v = vec![\"a\".to_string(), \"b\".to_string()]; let snapshot = v.clone(); v.push(\"c\".to_string()); println!(\"{:?}\", snapshot); }", "task_id": "borrow_checker_mut_borrow_conflict_043", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn handle_request(req: Request) -> Response { let auth = req.headers.get(\"Authorization\"); if auth.is_none() { return Response::unauthorized(); } let token = auth.unwrap(); if !verify_token(token) { return Response::forbidden(); } let body = req.body(); let data: Data = serde_json::from_str(body).unwrap(); let result = db::save(&data); match result { Ok(_) => Response::ok(), Err(e) => Response::error(e) } }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn authenticate(req: &Request) -> Result<&str, Response> { req.headers.get(\"Authorization\").filter(|t| verify_token(t)).ok_or_else(Response::unauthorized) } fn parse_body(req: &Request) -> Result<Data, Response> { serde_json::from_str(req.body()).map_err(|_| Response::bad_request()) } fn handle_request(req: Request) -> Response { let _token = match authenticate(&req) { Ok(t) => t, Err(r) => return r }; match parse_body(&req).and_then(|data| db::save(&data).map_err(|e| Response::error(e))) { Ok(_) => Response::ok(), Err(r) => r } }", "task_id": "complexity_decompose_long_function_004", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", msg); let _ = msg; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let msg = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", msg); let _ = msg.clone(); } }", "task_id": "borrow_checker_move_in_loop_085", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn find_item(v: &[i32], target: i32) -> Result<i32, &str> { v.iter().find(|&&x| x == target).copied() }\n```\n\n## Compiler Error:\nmismatched types: use ok_or to convert Option to Result\n\n## Fixed Code:", "output": "fn find_item(v: &[i32], target: i32) -> Result<i32, &str> { v.iter().find(|&&x| x == target).copied().ok_or(\"not found\") }", "task_id": "result_handling_option_ok_or_022", "family": "result_handling", "pattern": "option_ok_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Item { name: String } fn main() { let a = Item { name: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Item { name: String } fn main() { let a = Item { name: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_011", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; let first = nums.first(); println!(\"{}\", first); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let nums = vec![1, 2, 3]; if let Some(first) = nums.first() { println!(\"{}\", first); } }", "task_id": "result_handling_if_let_option_031", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn log(msg: &str, code: u32) { eprintln!(\"[{}] {}\", code, msg); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn log(msg: &str, code: u32) { eprintln!(\"[{code}] {msg}\"); }", "task_id": "rust_2024_inline_format_args_011", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_env(key: &str) -> Result<String, &str> { std::env::var(key) }\n```\n\n## Compiler Error:\nmismatched types: expected Result, use map_err to convert\n\n## Fixed Code:", "output": "fn get_env(key: &str) -> Result<String, &str> { std::env::var(key).map_err(|_| \"not found\") }", "task_id": "result_handling_option_to_result_map_err_012", "family": "result_handling", "pattern": "option_to_result_map_err"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::fs; fn read_bytes(path: &str) -> Vec<u8> { fs::read(path) }\n```\n\n## Compiler Error:\nmismatched types: expected String, found Result: propagate with Result return type\n\n## Fixed Code:", "output": "use std::fs; fn read_bytes(path: &str) -> std::io::Result<Vec<u8>> { fs::read(path) }", "task_id": "result_handling_propagate_error_070", "family": "result_handling", "pattern": "propagate_error"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Rect { width: i32 } fn main() { let r = Rect { width: 0 }; r.width = 5; }\n```\n\n## Compiler Error:\ncannot assign to field of immutable binding: add mut\n\n## Fixed Code:", "output": "struct Rect { width: i32 } fn main() { let mut r = Rect { width: 0 }; r.width = 5; }", "task_id": "borrow_checker_immutable_field_133", "family": "borrow_checker", "pattern": "immutable_field"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let maybe = Some(String::from(\"hi\")); match maybe { Some(val) => println!(\"{}\", val), None => {} } println!(\"{:?}\", maybe); }\n```\n\n## Compiler Error:\nborrow of moved value in match: match on reference instead\n\n## Fixed Code:", "output": "fn main() { let maybe = Some(String::from(\"hi\")); match &maybe { Some(val) => println!(\"{}\", val), None => {} } println!(\"{:?}\", maybe); }", "task_id": "borrow_checker_match_move_106", "family": "borrow_checker", "pattern": "match_move"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut items = vec![\"a\".to_string(), \"b\".to_string()]; let saved = &items; items.push(\"c\".to_string()); println!(\"{:?}\", saved); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut items = vec![\"a\".to_string(), \"b\".to_string()]; let saved = items.clone(); items.push(\"c\".to_string()); println!(\"{:?}\", saved); }", "task_id": "borrow_checker_mut_borrow_conflict_041", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut words = vec![\"a\".to_string(), \"b\".to_string()]; let copy = &words; words.push(\"c\".to_string()); println!(\"{:?}\", copy); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut words = vec![\"a\".to_string(), \"b\".to_string()]; let copy = words.clone(); words.push(\"c\".to_string()); println!(\"{:?}\", copy); }", "task_id": "borrow_checker_mut_borrow_conflict_039", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#![allow(clippy::all)] fn add(a: i32, b: i32) -> i32 { let result: i32 = a + b; return result; }\n```\n\n## Compiler Error:\nnever use blanket #[allow(clippy::all)]: fix the specific issues instead\n\n## Fixed Code:", "output": "fn add(a: i32, b: i32) -> i32 { a + b }", "task_id": "clippy_suppression_no_blanket_suppress_024", "family": "clippy_suppression", "pattern": "no_blanket_suppress"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut words = vec![\"a\".to_string(), \"b\".to_string()]; let copy = &words; words.push(\"c\".to_string()); println!(\"{:?}\", copy); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut words = vec![\"a\".to_string(), \"b\".to_string()]; let copy = words.clone(); words.push(\"c\".to_string()); println!(\"{:?}\", copy); }", "task_id": "borrow_checker_mut_borrow_conflict_045", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut v = vec![1, 2, 3]; let first = &v[0]; v.push(4); println!(\"{}\", first); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut v = vec![1, 2, 3]; let first = v[0]; v.push(4); println!(\"{}\", first); }", "task_id": "borrow_checker_mut_borrow_conflict_034", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", data); let _ = data; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let data = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", data); let _ = data.clone(); } }", "task_id": "borrow_checker_move_in_loop_089", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::uninlined_format_args)] fn log(level: &str, msg: &str) { eprintln!(\"[{}] {}\", level, msg); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format args instead of suppressing\n\n## Fixed Code:", "output": "fn log(level: &str, msg: &str) { eprintln!(\"[{level}] {msg}\"); }", "task_id": "clippy_suppression_no_suppress_format_args_011", "family": "clippy_suppression", "pattern": "no_suppress_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; let first = v.first(); println!(\"{}\", first); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let v = vec![1, 2, 3]; if let Some(first) = v.first() { println!(\"{}\", first); } }", "task_id": "result_handling_if_let_option_036", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::needless_collect)] fn count_positive(v: &[i32]) -> usize { let pos: Vec<&i32> = v.iter().filter(|x| **x > 0).collect(); pos.len() }\n```\n\n## Compiler Error:\nclippy::needless_collect: remove the unnecessary .collect() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn count_positive(v: &[i32]) -> usize { v.iter().filter(|x| **x > 0).count() }", "task_id": "clippy_suppression_no_suppress_needless_collect_003", "family": "clippy_suppression", "pattern": "no_suppress_needless_collect"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn read_num(s: &str) -> i32 { s.parse()? }\n```\n\n## Compiler Error:\nthe `?` operator can only be used in a function that returns `Result`\n\n## Fixed Code:", "output": "fn read_num(s: &str) -> Result<i32, std::num::ParseIntError> { Ok(s.parse()?) }", "task_id": "result_handling_question_mark_return_type_001", "family": "result_handling", "pattern": "question_mark_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let cache = std::collections::HashMap::from([(\"key\", 1)]); let val = cache.get(\"key\"); println!(\"{}\", val); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let cache = std::collections::HashMap::from([(\"key\", 1)]); if let Some(val) = cache.get(\"key\") { println!(\"{}\", val); } }", "task_id": "result_handling_if_let_option_041", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn first_char(s: &str) -> char { s.chars().next() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn first_char(s: &str) -> char { s.chars().next().unwrap_or(' ') }", "task_id": "result_handling_option_unwrap_or_008", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::from(\"hello\"); let t = s; println!(\"{}\", s); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let s = String::from(\"hello\"); let t = s.clone(); println!(\"{}\", s); }", "task_id": "borrow_checker_use_after_move_clone_004", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::uninlined_format_args)] fn greet(name: &str) { println!(\"Hello, {}\", name); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format args instead of suppressing\n\n## Fixed Code:", "output": "fn greet(name: &str) { println!(\"Hello, {name}\"); }", "task_id": "clippy_suppression_no_suppress_format_args_007", "family": "clippy_suppression", "pattern": "no_suppress_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn process(data: &str) -> Result<String, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } let parsed: i32 = trimmed.parse().map_err(|_| Error::Parse)?; let validated = if parsed < 0 { return Err(Error::Negative); } else { parsed }; let result = validated * 2 + 10; Ok(format!(\"result: {}\", result)) }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn parse_input(data: &str) -> Result<i32, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } trimmed.parse().map_err(|_| Error::Parse) } fn validate(n: i32) -> Result<i32, Error> { if n < 0 { Err(Error::Negative) } else { Ok(n) } } fn process(data: &str) -> Result<String, Error> { let parsed = parse_input(data)?; let validated = validate(parsed)?; Ok(format!(\"result: {}\", validated * 2 + 10)) }", "task_id": "complexity_decompose_long_function_001", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut data = String::from(\"hello\"); let x = &mut data; let y = &mut data; println!(\"{} {}\", x, y); }\n```\n\n## Compiler Error:\ncannot borrow as mutable more than once at a time\n\n## Fixed Code:", "output": "fn main() { let mut data = String::from(\"hello\"); let x = &mut data; println!(\"{}\", x); let y = &mut data; println!(\"{}\", y); }", "task_id": "borrow_checker_double_mut_borrow_077", "family": "borrow_checker", "pattern": "double_mut_borrow"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let content = std::fs::read_to_string(\"data.txt\")?; println!(\"{}\", content); }\n```\n\n## Compiler Error:\nthe `?` operator in main needs `fn main() -> Result<...>`\n\n## Fixed Code:", "output": "fn main() -> Result<(), Box<dyn std::error::Error>> { let content = std::fs::read_to_string(\"data.txt\")?; println!(\"{}\", content); Ok(()) }", "task_id": "result_handling_main_question_mark_027", "family": "result_handling", "pattern": "main_question_mark"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn sum(v: &Vec<i32>) -> i32 { v.iter().sum() }\n```\n\n## Compiler Error:\nclippy::ptr_arg: use &[T] instead of &Vec<T> in function parameters\n\n## Fixed Code:", "output": "fn sum(v: &[i32]) -> i32 { v.iter().sum() }", "task_id": "rust_2024_slice_param_058", "family": "rust_2024", "pattern": "slice_param"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_str() -> &str { let s = String::from(\"hello\"); &s }\n```\n\n## Compiler Error:\ncannot return reference to local variable: return owned type instead\n\n## Fixed Code:", "output": "fn get_str() -> String { String::from(\"hello\") }", "task_id": "borrow_checker_return_local_ref_139", "family": "borrow_checker", "pattern": "return_local_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let cache = std::collections::HashMap::new(); cache.insert(1, 2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut cache = std::collections::HashMap::new(); cache.insert(1, 2); }", "task_id": "borrow_checker_missing_mut_068", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Point { x: i32 } fn main() { let p = Point { x: 0 }; p.x = 5; }\n```\n\n## Compiler Error:\ncannot assign to field of immutable binding: add mut\n\n## Fixed Code:", "output": "struct Point { x: i32 } fn main() { let mut p = Point { x: 0 }; p.x = 5; }", "task_id": "borrow_checker_immutable_field_129", "family": "borrow_checker", "pattern": "immutable_field"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn print_it<T>(val: T) { println!(\"{:?}\", val); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add trait bound T: Debug\n\n## Fixed Code:", "output": "fn print_it<T: std::fmt::Debug>(val: T) { println!(\"{:?}\", val); }", "task_id": "trait_bounds_missing_generic_bound_037", "family": "trait_bounds", "pattern": "missing_generic_bound"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut s = String::from(\"hello\"); let r1 = &mut s; let r2 = &mut s; println!(\"{} {}\", r1, r2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable more than once at a time\n\n## Fixed Code:", "output": "fn main() { let mut s = String::from(\"hello\"); let r1 = &mut s; println!(\"{}\", r1); let r2 = &mut s; println!(\"{}\", r2); }", "task_id": "borrow_checker_double_mut_borrow_075", "family": "borrow_checker", "pattern": "double_mut_borrow"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn double_parse(s: &str) -> i32 { s.parse::<i32>().map(|n| n * 2) }\n```\n\n## Compiler Error:\nmismatched types: function returns Result but body doesn't\n\n## Fixed Code:", "output": "fn double_parse(s: &str) -> Result<i32, std::num::ParseIntError> { s.parse::<i32>().map(|n| n * 2) }", "task_id": "result_handling_result_map_return_type_059", "family": "result_handling", "pattern": "result_map_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_add(s: &str) -> i32 { s.parse::<i32>().map(|n| n + 1) }\n```\n\n## Compiler Error:\nmismatched types: function returns Result but body doesn't\n\n## Fixed Code:", "output": "fn parse_add(s: &str) -> Result<i32, std::num::ParseIntError> { s.parse::<i32>().map(|n| n + 1) }", "task_id": "result_handling_result_map_return_type_055", "family": "result_handling", "pattern": "result_map_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let n: i32 = \"abc\".parse(); println!(\"{}\", n); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Result: use match\n\n## Fixed Code:", "output": "fn main() { match \"abc\".parse::<i32>() { Ok(n) => println!(\"{}\", n), Err(e) => println!(\"Error: {}\", e) } }", "task_id": "result_handling_match_result_049", "family": "result_handling", "pattern": "match_result"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Options { limit: u32 } fn main() { let c: Options = Default::default(); }\n```\n\n## Compiler Error:\ndoesn't implement `Default`: add #[derive(Default)]\n\n## Fixed Code:", "output": "#[derive(Default)] struct Options { limit: u32 } fn main() { let c: Options = Default::default(); }", "task_id": "trait_bounds_missing_default_052", "family": "trait_bounds", "pattern": "missing_default"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut items = vec![\"a\".to_string(), \"b\".to_string()]; let saved = &items; items.push(\"c\".to_string()); println!(\"{:?}\", saved); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut items = vec![\"a\".to_string(), \"b\".to_string()]; let saved = items.clone(); items.push(\"c\".to_string()); println!(\"{:?}\", saved); }", "task_id": "borrow_checker_mut_borrow_conflict_038", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::collections::HashMap; struct Key { id: i32 } fn main() { let mut map = HashMap::new(); map.insert(Key { id: 1 }, \"value\"); }\n```\n\n## Compiler Error:\nthe trait `Hash` is not implemented: add #[derive(Hash, PartialEq, Eq)]\n\n## Fixed Code:", "output": "use std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Key { id: i32 } fn main() { let mut map = HashMap::new(); map.insert(Key { id: 1 }, \"value\"); }", "task_id": "trait_bounds_missing_hash_065", "family": "trait_bounds", "pattern": "missing_hash"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; v.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut v = vec![1, 2, 3]; v.push(4); }", "task_id": "borrow_checker_missing_mut_050", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::match_like_matches_macro)] fn is_vowel(c: char) -> bool { match c { 'a' | 'e' | 'i' | 'o' | 'u' => true, _ => false } }\n```\n\n## Compiler Error:\nclippy::match_like_matches_macro: use matches!() instead of suppressing\n\n## Fixed Code:", "output": "fn is_vowel(c: char) -> bool { matches!(c, 'a' | 'e' | 'i' | 'o' | 'u') }", "task_id": "clippy_suppression_no_suppress_matches_019", "family": "clippy_suppression", "pattern": "no_suppress_matches"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::collections::HashMap; struct Index { pos: i32 } fn main() { let mut map = HashMap::new(); map.insert(Index { pos: 1 }, \"value\"); }\n```\n\n## Compiler Error:\nthe trait `Hash` is not implemented: add #[derive(Hash, PartialEq, Eq)]\n\n## Fixed Code:", "output": "use std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Index { pos: i32 } fn main() { let mut map = HashMap::new(); map.insert(Index { pos: 1 }, \"value\"); }", "task_id": "trait_bounds_missing_hash_070", "family": "trait_bounds", "pattern": "missing_hash"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", msg); let _ = msg; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let msg = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", msg); let _ = msg.clone(); } }", "task_id": "borrow_checker_move_in_loop_088", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::from(\"world\"); let taken = msg; println!(\"{}\", taken); println!(\"{}\", msg); }\n```\n\n## Compiler Error:\nborrow of moved value: reorder statements so use comes before move\n\n## Fixed Code:", "output": "fn main() { let msg = String::from(\"world\"); println!(\"{}\", msg); let taken = msg; println!(\"{}\", taken); }", "task_id": "borrow_checker_use_after_move_reorder_026", "family": "borrow_checker", "pattern": "use_after_move_reorder"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn read_file(path: &str) -> String { std::fs::read_to_string(path)? }\n```\n\n## Compiler Error:\nthe `?` operator can only be used in a function that returns `Result`\n\n## Fixed Code:", "output": "fn read_file(path: &str) -> Result<String, std::io::Error> { Ok(std::fs::read_to_string(path)?) }", "task_id": "result_handling_question_mark_return_type_003", "family": "result_handling", "pattern": "question_mark_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Rect { width: i32 } fn main() { let r = Rect { width: 0 }; r.width = 5; }\n```\n\n## Compiler Error:\ncannot assign to field of immutable binding: add mut\n\n## Fixed Code:", "output": "struct Rect { width: i32 } fn main() { let mut r = Rect { width: 0 }; r.width = 5; }", "task_id": "borrow_checker_immutable_field_130", "family": "borrow_checker", "pattern": "immutable_field"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let map = std::collections::HashMap::new(); map.insert(1, 2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut map = std::collections::HashMap::new(); map.insert(1, 2); }", "task_id": "borrow_checker_missing_mut_066", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; for _ in 0..2 { let _ = v; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let v = vec![1, 2, 3]; for _ in 0..2 { let _ = v.clone(); } }", "task_id": "borrow_checker_move_in_loop_096", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![String::from(\"a\"), String::from(\"b\")]; let first = v[0]; }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn main() { let v = vec![String::from(\"a\"), String::from(\"b\")]; let first = v[0].clone(); }", "task_id": "borrow_checker_move_out_of_index_120", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn first_char(s: &str) -> char { s.chars().next() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn first_char(s: &str) -> char { s.chars().next().unwrap_or(' ') }", "task_id": "result_handling_option_unwrap_or_006", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = vec![1, 2, 3]; data.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut data = vec![1, 2, 3]; data.push(4); }", "task_id": "borrow_checker_missing_mut_053", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_somes(v: Vec<Option<i32>>) -> Vec<i32> { v.into_iter().filter(|x| x.is_some()).map(|x| x.unwrap()).collect() }\n```\n\n## Compiler Error:\nclippy::manual_flatten: use .flatten() instead of filter+unwrap\n\n## Fixed Code:", "output": "fn get_somes(v: Vec<Option<i32>>) -> Vec<i32> { v.into_iter().flatten().collect() }", "task_id": "rust_2024_use_flatten_033", "family": "rust_2024", "pattern": "use_flatten"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::rc::Rc; fn send_to_thread<T: Send>(val: T) {} fn main() { let rc = Rc::new(5); send_to_thread(rc); }\n```\n\n## Compiler Error:\n`Rc` cannot be sent between threads safely: use Arc instead\n\n## Fixed Code:", "output": "use std::sync::Arc; fn send_to_thread<T: Send>(val: T) {} fn main() { let rc = Arc::new(5); send_to_thread(rc); }", "task_id": "trait_bounds_rc_not_send_086", "family": "trait_bounds", "pattern": "rc_not_send"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::collections::HashMap; struct Tag { code: i32 } fn main() { let mut map = HashMap::new(); map.insert(Tag { code: 1 }, \"value\"); }\n```\n\n## Compiler Error:\nthe trait `Hash` is not implemented: add #[derive(Hash, PartialEq, Eq)]\n\n## Fixed Code:", "output": "use std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Tag { code: i32 } fn main() { let mut map = HashMap::new(); map.insert(Tag { code: 1 }, \"value\"); }", "task_id": "trait_bounds_missing_hash_063", "family": "trait_bounds", "pattern": "missing_hash"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Entry { key: String } fn main() { let a = Entry { key: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Entry { key: String } fn main() { let a = Entry { key: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_012", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Point { x: i32, y: i32 } fn main() { let a = Point { x: 1, y: 2 }; let b = Point { x: 1, y: 2 }; println!(\"{}\", a == b); }\n```\n\n## Compiler Error:\nbinary operation `==` cannot be applied: add #[derive(PartialEq)]\n\n## Fixed Code:", "output": "#[derive(PartialEq)] struct Point { x: i32, y: i32 } fn main() { let a = Point { x: 1, y: 2 }; let b = Point { x: 1, y: 2 }; println!(\"{}\", a == b); }", "task_id": "trait_bounds_missing_partial_eq_059", "family": "trait_bounds", "pattern": "missing_partial_eq"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut v = vec![1, 2, 3]; let first = &v[0]; v.push(4); println!(\"{}\", first); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut v = vec![1, 2, 3]; let first = v[0]; v.push(4); println!(\"{}\", first); }", "task_id": "borrow_checker_mut_borrow_conflict_031", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let map = std::collections::HashMap::new(); map.insert(1, 2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut map = std::collections::HashMap::new(); map.insert(1, 2); }", "task_id": "borrow_checker_missing_mut_072", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Label { value: String } fn main() { let m = Label { value: \"hello\".into() }; println!(\"{}\", m); }\n```\n\n## Compiler Error:\ndoesn't implement `std::fmt::Display`: implement Display trait\n\n## Fixed Code:", "output": "use std::fmt; struct Label { value: String } impl fmt::Display for Label { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"{}\", self.value) } } fn main() { let m = Label { value: \"hello\".into() }; println!(\"{}\", m); }", "task_id": "trait_bounds_missing_display_096", "family": "trait_bounds", "pattern": "missing_display"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Priority { level: i32 } fn main() { let mut items = vec![Priority { level: 3 }, Priority { level: 1 }]; items.sort(); }\n```\n\n## Compiler Error:\nthe trait `Ord` is not implemented: add #[derive(PartialEq, Eq, PartialOrd, Ord)]\n\n## Fixed Code:", "output": "#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Priority { level: i32 } fn main() { let mut items = vec![Priority { level: 3 }, Priority { level: 1 }]; items.sort(); }", "task_id": "trait_bounds_missing_ord_078", "family": "trait_bounds", "pattern": "missing_ord"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::collections::HashMap; struct Key { id: i32 } fn main() { let mut map = HashMap::new(); map.insert(Key { id: 1 }, \"value\"); }\n```\n\n## Compiler Error:\nthe trait `Hash` is not implemented: add #[derive(Hash, PartialEq, Eq)]\n\n## Fixed Code:", "output": "use std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Key { id: i32 } fn main() { let mut map = HashMap::new(); map.insert(Key { id: 1 }, \"value\"); }", "task_id": "trait_bounds_missing_hash_068", "family": "trait_bounds", "pattern": "missing_hash"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Record { text: String } fn main() { let a = Record { text: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Record { text: String } fn main() { let a = Record { text: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_017", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Rank { pos: i32 } fn main() { let mut items = vec![Rank { pos: 3 }, Rank { pos: 1 }]; items.sort(); }\n```\n\n## Compiler Error:\nthe trait `Ord` is not implemented: add #[derive(PartialEq, Eq, PartialOrd, Ord)]\n\n## Fixed Code:", "output": "#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Rank { pos: i32 } fn main() { let mut items = vec![Rank { pos: 3 }, Rank { pos: 1 }]; items.sort(); }", "task_id": "trait_bounds_missing_ord_079", "family": "trait_bounds", "pattern": "missing_ord"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut text = String::from(\"hello\"); let a = &mut text; let b = &mut text; println!(\"{} {}\", a, b); }\n```\n\n## Compiler Error:\ncannot borrow as mutable more than once at a time\n\n## Fixed Code:", "output": "fn main() { let mut text = String::from(\"hello\"); let a = &mut text; println!(\"{}\", a); let b = &mut text; println!(\"{}\", b); }", "task_id": "borrow_checker_double_mut_borrow_076", "family": "borrow_checker", "pattern": "double_mut_borrow"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let table = std::collections::HashMap::from([(\"key\", 1)]); let val = table.get(\"key\"); println!(\"{}\", val); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let table = std::collections::HashMap::from([(\"key\", 1)]); if let Some(val) = table.get(\"key\") { println!(\"{}\", val); } }", "task_id": "result_handling_if_let_option_046", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn create() -> &String { let s = String::from(\"test\"); &s }\n```\n\n## Compiler Error:\ncannot return reference to local variable: return owned type instead\n\n## Fixed Code:", "output": "fn create() -> String { String::from(\"test\") }", "task_id": "borrow_checker_return_local_ref_144", "family": "borrow_checker", "pattern": "return_local_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; let w = v; println!(\"{:?}\", v); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let v = vec![1, 2, 3]; let w = v.clone(); println!(\"{:?}\", v); }", "task_id": "borrow_checker_use_after_move_clone_010", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let text = String::new(); text.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut text = String::new(); text.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_065", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let n: i32 = \"abc\".parse(); println!(\"{}\", n); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Result: use match\n\n## Fixed Code:", "output": "fn main() { match \"abc\".parse::<i32>() { Ok(n) => println!(\"{}\", n), Err(e) => println!(\"Error: {}\", e) } }", "task_id": "result_handling_match_result_048", "family": "result_handling", "pattern": "match_result"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_int(s: &str) -> Result<i32, &str> { s.parse() }\n```\n\n## Compiler Error:\nmismatched types: expected Result, use map_err to convert\n\n## Fixed Code:", "output": "fn parse_int(s: &str) -> Result<i32, &str> { s.parse().map_err(|_| \"parse error\") }", "task_id": "result_handling_option_to_result_map_err_016", "family": "result_handling", "pattern": "option_to_result_map_err"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Status { msg: String } fn main() { let m = Status { msg: \"hello\".into() }; println!(\"{}\", m); }\n```\n\n## Compiler Error:\ndoesn't implement `std::fmt::Display`: implement Display trait\n\n## Fixed Code:", "output": "use std::fmt; struct Status { msg: String } impl fmt::Display for Status { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"{}\", self.msg) } } fn main() { let m = Status { msg: \"hello\".into() }; println!(\"{}\", m); }", "task_id": "trait_bounds_missing_display_097", "family": "trait_bounds", "pattern": "missing_display"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let maybe = Some(String::from(\"hi\")); match maybe { Some(val) => println!(\"{}\", val), None => {} } println!(\"{:?}\", maybe); }\n```\n\n## Compiler Error:\nborrow of moved value in match: match on reference instead\n\n## Fixed Code:", "output": "fn main() { let maybe = Some(String::from(\"hi\")); match &maybe { Some(val) => println!(\"{}\", val), None => {} } println!(\"{:?}\", maybe); }", "task_id": "borrow_checker_match_move_109", "family": "borrow_checker", "pattern": "match_move"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::new(); s.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut s = String::new(); s.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_064", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn last_elem(v: &[i32]) -> i32 { *v.last() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn last_elem(v: &[i32]) -> i32 { *v.last().unwrap_or(&0) }", "task_id": "result_handling_option_unwrap_or_009", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn log(text: &str, level: u32) { eprintln!(\"[{}] {}\", level, text); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn log(text: &str, level: u32) { eprintln!(\"[{level}] {text}\"); }", "task_id": "rust_2024_inline_format_args_014", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = String::from(\"test\"); let backup = data; println!(\"{}\", data); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let data = String::from(\"test\"); let backup = data.clone(); println!(\"{}\", data); }", "task_id": "borrow_checker_use_after_move_clone_006", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Config { value: String } fn main() { let x = Config { value: String::from(\"test\") }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct Config { value: String } fn main() { let x = Config { value: String::from(\"test\") }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_006", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn check(opt: Option<i32>) -> bool { if let Some(x) = opt { if x > 0 { return true; } } false }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn check(opt: Option<i32>) -> bool { if let Some(x) = opt && x > 0 { return true; } false }", "task_id": "rust_2024_let_chains_039", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_or_compute(opt: Option<i32>) -> i32 { opt.unwrap_or(expensive_default()) } fn expensive_default() -> i32 { 42 }\n```\n\n## Compiler Error:\nunnecessary eager evaluation: use unwrap_or_else for lazy default\n\n## Fixed Code:", "output": "fn get_or_compute(opt: Option<i32>) -> i32 { opt.unwrap_or_else(|| expensive_default()) } fn expensive_default() -> i32 { 42 }", "task_id": "result_handling_unwrap_or_else_061", "family": "result_handling", "pattern": "unwrap_or_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn log(text: &str, level: u32) { eprintln!(\"[{}] {}\", level, text); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn log(text: &str, level: u32) { eprintln!(\"[{level}] {text}\"); }", "task_id": "rust_2024_inline_format_args_010", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let map = std::collections::HashMap::new(); map.insert(1, 2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut map = std::collections::HashMap::new(); map.insert(1, 2); }", "task_id": "borrow_checker_missing_mut_069", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; for _ in 0..2 { let _ = nums; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let nums = vec![1, 2, 3]; for _ in 0..2 { let _ = nums.clone(); } }", "task_id": "borrow_checker_move_in_loop_094", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let cache = std::collections::HashMap::new(); cache.insert(1, 2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut cache = std::collections::HashMap::new(); cache.insert(1, 2); }", "task_id": "borrow_checker_missing_mut_074", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::from(\"foo\"); let saved = msg; println!(\"{}\", msg); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let msg = String::from(\"foo\"); let saved = msg.clone(); println!(\"{}\", msg); }", "task_id": "borrow_checker_use_after_move_clone_007", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Entry { key: String } fn main() { let a = Entry { key: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Entry { key: String } fn main() { let a = Entry { key: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_016", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut v = vec![\"a\".to_string(), \"b\".to_string()]; let snapshot = &v; v.push(\"c\".to_string()); println!(\"{:?}\", snapshot); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut v = vec![\"a\".to_string(), \"b\".to_string()]; let snapshot = v.clone(); v.push(\"c\".to_string()); println!(\"{:?}\", snapshot); }", "task_id": "borrow_checker_mut_borrow_conflict_037", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Coord { x: i32 } fn double(n: Coord) -> i32 { n.x * 2 } fn main() { let n = Coord { x: 5 }; println!(\"{} {}\", double(n), double(n)); }\n```\n\n## Compiler Error:\nuse of moved value: add #[derive(Clone, Copy)]\n\n## Fixed Code:", "output": "#[derive(Clone, Copy)] struct Coord { x: i32 } fn double(n: Coord) -> i32 { n.x * 2 } fn main() { let n = Coord { x: 5 }; println!(\"{} {}\", double(n), double(n)); }", "task_id": "trait_bounds_missing_copy_030", "family": "trait_bounds", "pattern": "missing_copy"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Point { x: i32 } fn main() { let x = Point { x: 5 }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct Point { x: i32 } fn main() { let x = Point { x: 5 }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_004", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Config { value: String } fn main() { let x = Config { value: String::from(\"test\") }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct Config { value: String } fn main() { let x = Config { value: String::from(\"test\") }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_002", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct User { id: u32 } fn main() { let x = User { id: 1 }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct User { id: u32 } fn main() { let x = User { id: 1 }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_009", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::fs; fn read_bytes(path: &str) -> Vec<u8> { fs::read(path) }\n```\n\n## Compiler Error:\nmismatched types: expected String, found Result: propagate with Result return type\n\n## Fixed Code:", "output": "use std::fs; fn read_bytes(path: &str) -> std::io::Result<Vec<u8>> { fs::read(path) }", "task_id": "result_handling_propagate_error_069", "family": "result_handling", "pattern": "propagate_error"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_or_default(s: &str) -> i32 { match s.parse() { Ok(n) => n, Err(_) => return -1 } }\n```\n\n## Compiler Error:\nuse let-else pattern for early returns on None/Err\n\n## Fixed Code:", "output": "fn parse_or_default(s: &str) -> i32 { let Ok(n) = s.parse() else { return -1; }; n }", "task_id": "rust_2024_let_else_049", "family": "rust_2024", "pattern": "let_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn double_all(v: &[i32]) -> Vec<i32> { v.iter().cloned().map(|x| x * 2).collect() }\n```\n\n## Compiler Error:\nclippy::cloned_instead_of_copied: use .copied() for Copy types\n\n## Fixed Code:", "output": "fn double_all(v: &[i32]) -> Vec<i32> { v.iter().copied().map(|x| x * 2).collect() }", "task_id": "rust_2024_iter_copied_022", "family": "rust_2024", "pattern": "iter_copied"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; for _ in 0..2 { let _ = v; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let v = vec![1, 2, 3]; for _ in 0..2 { let _ = v.clone(); } }", "task_id": "borrow_checker_move_in_loop_099", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_first(v: &[&str]) -> Result<i32, &str> { v.first().map(|s| s.parse().unwrap()) }\n```\n\n## Compiler Error:\nmismatched types: use ok_or to convert Option to Result\n\n## Fixed Code:", "output": "fn parse_first(v: &[&str]) -> Result<i32, &str> { v.first().ok_or(\"empty\")?.parse().map_err(|_| \"parse error\") }", "task_id": "result_handling_option_ok_or_018", "family": "result_handling", "pattern": "option_ok_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; for _ in 0..2 { let _ = nums; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let nums = vec![1, 2, 3]; for _ in 0..2 { let _ = nums.clone(); } }", "task_id": "borrow_checker_move_in_loop_097", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn greet(name: &str) { println!(\"Hello, {}\", name); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn greet(name: &str) { println!(\"Hello, {name}\"); }", "task_id": "rust_2024_inline_format_args_000", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Rank { pos: i32 } fn main() { let mut items = vec![Rank { pos: 3 }, Rank { pos: 1 }]; items.sort(); }\n```\n\n## Compiler Error:\nthe trait `Ord` is not implemented: add #[derive(PartialEq, Eq, PartialOrd, Ord)]\n\n## Fixed Code:", "output": "#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Rank { pos: i32 } fn main() { let mut items = vec![Rank { pos: 3 }, Rank { pos: 1 }]; items.sort(); }", "task_id": "trait_bounds_missing_ord_073", "family": "trait_bounds", "pattern": "missing_ord"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; let first = v.first(); println!(\"{}\", first); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let v = vec![1, 2, 3]; if let Some(first) = v.first() { println!(\"{}\", first); } }", "task_id": "result_handling_if_let_option_033", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(unused_must_use)] fn remove(path: &str) { std::fs::remove_file(path); }\n```\n\n## Compiler Error:\ndon't suppress unused Result: handle the error properly\n\n## Fixed Code:", "output": "fn remove(path: &str) -> std::io::Result<()> { std::fs::remove_file(path) }", "task_id": "clippy_suppression_no_suppress_must_use_031", "family": "clippy_suppression", "pattern": "no_suppress_must_use"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![String::from(\"a\"), String::from(\"b\")]; let first = v[0]; }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn main() { let v = vec![String::from(\"a\"), String::from(\"b\")]; let first = v[0].clone(); }", "task_id": "borrow_checker_move_out_of_index_123", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn compare<T>(a: T, b: T) -> bool { a == b }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add trait bound T: Debug\n\n## Fixed Code:", "output": "fn compare<T: PartialEq>(a: T, b: T) -> bool { a == b }", "task_id": "trait_bounds_missing_generic_bound_043", "family": "trait_bounds", "pattern": "missing_generic_bound"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Coord { x: i32 } fn double(n: Coord) -> i32 { n.x * 2 } fn main() { let n = Coord { x: 5 }; println!(\"{} {}\", double(n), double(n)); }\n```\n\n## Compiler Error:\nuse of moved value: add #[derive(Clone, Copy)]\n\n## Fixed Code:", "output": "#[derive(Clone, Copy)] struct Coord { x: i32 } fn double(n: Coord) -> i32 { n.x * 2 } fn main() { let n = Coord { x: 5 }; println!(\"{} {}\", double(n), double(n)); }", "task_id": "trait_bounds_missing_copy_033", "family": "trait_bounds", "pattern": "missing_copy"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::match_like_matches_macro)] fn is_vowel(c: char) -> bool { match c { 'a' | 'e' | 'i' | 'o' | 'u' => true, _ => false } }\n```\n\n## Compiler Error:\nclippy::match_like_matches_macro: use matches!() instead of suppressing\n\n## Fixed Code:", "output": "fn is_vowel(c: char) -> bool { matches!(c, 'a' | 'e' | 'i' | 'o' | 'u') }", "task_id": "clippy_suppression_no_suppress_matches_018", "family": "clippy_suppression", "pattern": "no_suppress_matches"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::rc::Rc; fn send_to_thread<T: Send>(val: T) {} fn main() { let shared = Rc::new(5); send_to_thread(shared); }\n```\n\n## Compiler Error:\n`Rc` cannot be sent between threads safely: use Arc instead\n\n## Fixed Code:", "output": "use std::sync::Arc; fn send_to_thread<T: Send>(val: T) {} fn main() { let shared = Arc::new(5); send_to_thread(shared); }", "task_id": "trait_bounds_rc_not_send_081", "family": "trait_bounds", "pattern": "rc_not_send"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn greet(who: &str) { println!(\"Hello, {}\", who); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn greet(who: &str) { println!(\"Hello, {who}\"); }", "task_id": "rust_2024_inline_format_args_008", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt { if !s.is_empty() { return Some(s); } } None }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt && !s.is_empty() { return Some(s); } None }", "task_id": "rust_2024_let_chains_042", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn compare<T>(a: T, b: T) -> bool { a == b }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add trait bound T: Debug\n\n## Fixed Code:", "output": "fn compare<T: PartialEq>(a: T, b: T) -> bool { a == b }", "task_id": "trait_bounds_missing_generic_bound_041", "family": "trait_bounds", "pattern": "missing_generic_bound"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct App { db_host: String, db_port: u16, db_name: String, cache_host: String, cache_port: u16, log_level: String, log_file: String, server_host: String, server_port: u16 }\n```\n\n## Compiler Error:\nstruct has too many fields: decompose into smaller focused types\n\n## Fixed Code:", "output": "struct DbConfig { host: String, port: u16, name: String }\nstruct CacheConfig { host: String, port: u16 }\nstruct LogConfig { level: String, file: String }\nstruct ServerConfig { host: String, port: u16 }\nstruct App { db: DbConfig, cache: CacheConfig, log: LogConfig, server: ServerConfig }", "task_id": "complexity_decompose_god_struct_012", "family": "complexity", "pattern": "decompose_god_struct"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Score { value: i32 } fn main() { let a = Score { value: 42 }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Score { value: i32 } fn main() { let a = Score { value: 42 }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_022", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Label { value: String } fn main() { let m = Label { value: \"hello\".into() }; println!(\"{}\", m); }\n```\n\n## Compiler Error:\ndoesn't implement `std::fmt::Display`: implement Display trait\n\n## Fixed Code:", "output": "use std::fmt; struct Label { value: String } impl fmt::Display for Label { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"{}\", self.value) } } fn main() { let m = Label { value: \"hello\".into() }; println!(\"{}\", m); }", "task_id": "trait_bounds_missing_display_090", "family": "trait_bounds", "pattern": "missing_display"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn take(val: String) {} fn main() { let mut data = vec![String::from(\"a\")]; take(data[0]); }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn take(val: String) {} fn main() { let mut data = vec![String::from(\"a\")]; take(data.remove(0)); }", "task_id": "borrow_checker_move_out_of_index_113", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::from(\"hello\"); let t = s; println!(\"{}\", t); println!(\"{}\", s); }\n```\n\n## Compiler Error:\nborrow of moved value: reorder statements so use comes before move\n\n## Fixed Code:", "output": "fn main() { let s = String::from(\"hello\"); println!(\"{}\", s); let t = s; println!(\"{}\", t); }", "task_id": "borrow_checker_use_after_move_reorder_019", "family": "borrow_checker", "pattern": "use_after_move_reorder"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Item { name: String } fn main() { let a = Item { name: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Item { name: String } fn main() { let a = Item { name: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_015", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn take(item: String) {} fn main() { let mut items = vec![String::from(\"a\")]; take(items[0]); }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn take(item: String) {} fn main() { let mut items = vec![String::from(\"a\")]; take(items.remove(0)); }", "task_id": "borrow_checker_move_out_of_index_118", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Settings { retries: u32 } fn main() { let c: Settings = Default::default(); }\n```\n\n## Compiler Error:\ndoesn't implement `Default`: add #[derive(Default)]\n\n## Fixed Code:", "output": "#[derive(Default)] struct Settings { retries: u32 } fn main() { let c: Settings = Default::default(); }", "task_id": "trait_bounds_missing_default_045", "family": "trait_bounds", "pattern": "missing_default"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_or_compute(opt: Option<i32>) -> i32 { opt.unwrap_or(expensive_default()) } fn expensive_default() -> i32 { 42 }\n```\n\n## Compiler Error:\nunnecessary eager evaluation: use unwrap_or_else for lazy default\n\n## Fixed Code:", "output": "fn get_or_compute(opt: Option<i32>) -> i32 { opt.unwrap_or_else(|| expensive_default()) } fn expensive_default() -> i32 { 42 }", "task_id": "result_handling_unwrap_or_else_060", "family": "result_handling", "pattern": "unwrap_or_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Num { v: i32 } fn double(n: Num) -> i32 { n.v * 2 } fn main() { let n = Num { v: 5 }; println!(\"{} {}\", double(n), double(n)); }\n```\n\n## Compiler Error:\nuse of moved value: add #[derive(Clone, Copy)]\n\n## Fixed Code:", "output": "#[derive(Clone, Copy)] struct Num { v: i32 } fn double(n: Num) -> i32 { n.v * 2 } fn main() { let n = Num { v: 5 }; println!(\"{} {}\", double(n), double(n)); }", "task_id": "trait_bounds_missing_copy_026", "family": "trait_bounds", "pattern": "missing_copy"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn log(msg: &str, code: u32) { eprintln!(\"[{}] {}\", code, msg); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn log(msg: &str, code: u32) { eprintln!(\"[{code}] {msg}\"); }", "task_id": "rust_2024_inline_format_args_009", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n// lib.rs with too many functions\npub fn create_user() {} pub fn get_user() {} pub fn update_user() {} pub fn delete_user() {} pub fn list_users() {} pub fn create_post() {} pub fn get_post() {} pub fn update_post() {} pub fn delete_post() {} pub fn list_posts() {} pub fn create_comment() {} pub fn get_comment() {}\n```\n\n## Compiler Error:\ntoo many functions in module: split into focused submodules\n\n## Fixed Code:", "output": "// lib.rs\npub mod users;\npub mod posts;\npub mod comments;\n\n// users.rs\npub fn create() {} pub fn get() {} pub fn update() {} pub fn delete() {} pub fn list() {}\n\n// posts.rs\npub fn create() {} pub fn get() {} pub fn update() {} pub fn delete() {} pub fn list() {}\n\n// comments.rs\npub fn create() {} pub fn get() {}", "task_id": "complexity_split_large_module_008", "family": "complexity", "pattern": "split_large_module"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::uninlined_format_args)] fn greet(name: &str) { println!(\"Hello, {}\", name); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format args instead of suppressing\n\n## Fixed Code:", "output": "fn greet(name: &str) { println!(\"Hello, {name}\"); }", "task_id": "clippy_suppression_no_suppress_format_args_006", "family": "clippy_suppression", "pattern": "no_suppress_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Num { v: i32 } fn double(n: Num) -> i32 { n.v * 2 } fn main() { let n = Num { v: 5 }; println!(\"{} {}\", double(n), double(n)); }\n```\n\n## Compiler Error:\nuse of moved value: add #[derive(Clone, Copy)]\n\n## Fixed Code:", "output": "#[derive(Clone, Copy)] struct Num { v: i32 } fn double(n: Num) -> i32 { n.v * 2 } fn main() { let n = Num { v: 5 }; println!(\"{} {}\", double(n), double(n)); }", "task_id": "trait_bounds_missing_copy_032", "family": "trait_bounds", "pattern": "missing_copy"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn is_digit(c: char) -> bool { match c { '0'..='9' => true, _ => false } }\n```\n\n## Compiler Error:\nclippy::match_like_matches_macro: use matches!() macro\n\n## Fixed Code:", "output": "fn is_digit(c: char) -> bool { matches!(c, '0'..='9') }", "task_id": "rust_2024_use_matches_macro_029", "family": "rust_2024", "pattern": "use_matches_macro"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn unwrap_or_ret(opt: Option<i32>) -> i32 { match opt { Some(x) => x, None => return 0 } }\n```\n\n## Compiler Error:\nuse let-else pattern for early returns on None/Err\n\n## Fixed Code:", "output": "fn unwrap_or_ret(opt: Option<i32>) -> i32 { let Some(x) = opt else { return 0; }; x }", "task_id": "rust_2024_let_else_047", "family": "rust_2024", "pattern": "let_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let text = String::from(\"data\"); let moved = text; println!(\"{}\", moved); println!(\"{}\", text); }\n```\n\n## Compiler Error:\nborrow of moved value: reorder statements so use comes before move\n\n## Fixed Code:", "output": "fn main() { let text = String::from(\"data\"); println!(\"{}\", text); let moved = text; println!(\"{}\", moved); }", "task_id": "borrow_checker_use_after_move_reorder_027", "family": "borrow_checker", "pattern": "use_after_move_reorder"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::collections::HashMap; struct Index { pos: i32 } fn main() { let mut map = HashMap::new(); map.insert(Index { pos: 1 }, \"value\"); }\n```\n\n## Compiler Error:\nthe trait `Hash` is not implemented: add #[derive(Hash, PartialEq, Eq)]\n\n## Fixed Code:", "output": "use std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Index { pos: i32 } fn main() { let mut map = HashMap::new(); map.insert(Index { pos: 1 }, \"value\"); }", "task_id": "trait_bounds_missing_hash_064", "family": "trait_bounds", "pattern": "missing_hash"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let maybe = Some(String::from(\"hi\")); match maybe { Some(val) => println!(\"{}\", val), None => {} } println!(\"{:?}\", maybe); }\n```\n\n## Compiler Error:\nborrow of moved value in match: match on reference instead\n\n## Fixed Code:", "output": "fn main() { let maybe = Some(String::from(\"hi\")); match &maybe { Some(val) => println!(\"{}\", val), None => {} } println!(\"{:?}\", maybe); }", "task_id": "borrow_checker_match_move_103", "family": "borrow_checker", "pattern": "match_move"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Point { x: i32, y: i32 } fn main() { let a = Point { x: 1, y: 2 }; let b = Point { x: 1, y: 2 }; println!(\"{}\", a == b); }\n```\n\n## Compiler Error:\nbinary operation `==` cannot be applied: add #[derive(PartialEq)]\n\n## Fixed Code:", "output": "#[derive(PartialEq)] struct Point { x: i32, y: i32 } fn main() { let a = Point { x: 1, y: 2 }; let b = Point { x: 1, y: 2 }; println!(\"{}\", a == b); }", "task_id": "trait_bounds_missing_partial_eq_053", "family": "trait_bounds", "pattern": "missing_partial_eq"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::from(\"hello\"); let t = s; println!(\"{}\", t); println!(\"{}\", s); }\n```\n\n## Compiler Error:\nborrow of moved value: reorder statements so use comes before move\n\n## Fixed Code:", "output": "fn main() { let s = String::from(\"hello\"); println!(\"{}\", s); let t = s; println!(\"{}\", t); }", "task_id": "borrow_checker_use_after_move_reorder_025", "family": "borrow_checker", "pattern": "use_after_move_reorder"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_int(s: &str) -> Result<i32, &str> { s.parse() }\n```\n\n## Compiler Error:\nmismatched types: expected Result, use map_err to convert\n\n## Fixed Code:", "output": "fn parse_int(s: &str) -> Result<i32, &str> { s.parse().map_err(|_| \"parse error\") }", "task_id": "result_handling_option_to_result_map_err_017", "family": "result_handling", "pattern": "option_to_result_map_err"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Score { value: i32 } fn main() { let a = Score { value: 42 }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Score { value: i32 } fn main() { let a = Score { value: 42 }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_020", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn is_valid(res: Result<i32, &str>) -> bool { res.map(|x| x >= 0).unwrap_or(false) }\n```\n\n## Compiler Error:\nuse is_some_and/is_ok_and instead of map+unwrap_or\n\n## Fixed Code:", "output": "fn is_valid(res: Result<i32, &str>) -> bool { res.is_ok_and(|x| x >= 0) }", "task_id": "rust_2024_is_some_and_054", "family": "rust_2024", "pattern": "is_some_and"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn greet(name: &str) { println!(\"Hello, {}\", name); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn greet(name: &str) { println!(\"Hello, {name}\"); }", "task_id": "rust_2024_inline_format_args_003", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let opt = Some(String::from(\"hi\")); match opt { Some(s) => println!(\"{}\", s), None => {} } println!(\"{:?}\", opt); }\n```\n\n## Compiler Error:\nborrow of moved value in match: match on reference instead\n\n## Fixed Code:", "output": "fn main() { let opt = Some(String::from(\"hi\")); match &opt { Some(s) => println!(\"{}\", s), None => {} } println!(\"{:?}\", opt); }", "task_id": "borrow_checker_match_move_105", "family": "borrow_checker", "pattern": "match_move"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::rc::Rc; fn send_to_thread<T: Send>(val: T) {} fn main() { let shared = Rc::new(5); send_to_thread(shared); }\n```\n\n## Compiler Error:\n`Rc` cannot be sent between threads safely: use Arc instead\n\n## Fixed Code:", "output": "use std::sync::Arc; fn send_to_thread<T: Send>(val: T) {} fn main() { let shared = Arc::new(5); send_to_thread(shared); }", "task_id": "trait_bounds_rc_not_send_084", "family": "trait_bounds", "pattern": "rc_not_send"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", s); let _ = s; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let s = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", s); let _ = s.clone(); } }", "task_id": "borrow_checker_move_in_loop_090", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_somes(v: Vec<Option<i32>>) -> Vec<i32> { v.into_iter().filter(|x| x.is_some()).map(|x| x.unwrap()).collect() }\n```\n\n## Compiler Error:\nclippy::manual_flatten: use .flatten() instead of filter+unwrap\n\n## Fixed Code:", "output": "fn get_somes(v: Vec<Option<i32>>) -> Vec<i32> { v.into_iter().flatten().collect() }", "task_id": "rust_2024_use_flatten_034", "family": "rust_2024", "pattern": "use_flatten"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let cache = std::collections::HashMap::from([(\"key\", 1)]); let val = cache.get(\"key\"); println!(\"{}\", val); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let cache = std::collections::HashMap::from([(\"key\", 1)]); if let Some(val) = cache.get(\"key\") { println!(\"{}\", val); } }", "task_id": "result_handling_if_let_option_044", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Amount { qty: i32 } fn double(n: Amount) -> i32 { n.qty * 2 } fn main() { let n = Amount { qty: 5 }; println!(\"{} {}\", double(n), double(n)); }\n```\n\n## Compiler Error:\nuse of moved value: add #[derive(Clone, Copy)]\n\n## Fixed Code:", "output": "#[derive(Clone, Copy)] struct Amount { qty: i32 } fn double(n: Amount) -> i32 { n.qty * 2 } fn main() { let n = Amount { qty: 5 }; println!(\"{} {}\", double(n), double(n)); }", "task_id": "trait_bounds_missing_copy_031", "family": "trait_bounds", "pattern": "missing_copy"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let content: String = std::fs::read_to_string(\"file.txt\"); println!(\"{}\", content); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Result: use match\n\n## Fixed Code:", "output": "fn main() { match std::fs::read_to_string(\"file.txt\") { Ok(content) => println!(\"{}\", content), Err(e) => println!(\"Error: {}\", e) } }", "task_id": "result_handling_match_result_052", "family": "result_handling", "pattern": "match_result"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; items.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut items = vec![1, 2, 3]; items.push(4); }", "task_id": "borrow_checker_missing_mut_048", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let item = Some(String::from(\"hi\")); match item { Some(x) => println!(\"{}\", x), None => {} } println!(\"{:?}\", item); }\n```\n\n## Compiler Error:\nborrow of moved value in match: match on reference instead\n\n## Fixed Code:", "output": "fn main() { let item = Some(String::from(\"hi\")); match &item { Some(x) => println!(\"{}\", x), None => {} } println!(\"{:?}\", item); }", "task_id": "borrow_checker_match_move_104", "family": "borrow_checker", "pattern": "match_move"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn is_digit(c: char) -> bool { match c { '0'..='9' => true, _ => false } }\n```\n\n## Compiler Error:\nclippy::match_like_matches_macro: use matches!() macro\n\n## Fixed Code:", "output": "fn is_digit(c: char) -> bool { matches!(c, '0'..='9') }", "task_id": "rust_2024_use_matches_macro_028", "family": "rust_2024", "pattern": "use_matches_macro"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::new(); msg.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut msg = String::new(); msg.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_062", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Status { msg: String } fn main() { let m = Status { msg: \"hello\".into() }; println!(\"{}\", m); }\n```\n\n## Compiler Error:\ndoesn't implement `std::fmt::Display`: implement Display trait\n\n## Fixed Code:", "output": "use std::fmt; struct Status { msg: String } impl fmt::Display for Status { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"{}\", self.msg) } } fn main() { let m = Status { msg: \"hello\".into() }; println!(\"{}\", m); }", "task_id": "trait_bounds_missing_display_091", "family": "trait_bounds", "pattern": "missing_display"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Point { x: i32 } fn main() { let x = Point { x: 5 }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct Point { x: i32 } fn main() { let x = Point { x: 5 }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_000", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn create() -> &String { let s = String::from(\"test\"); &s }\n```\n\n## Compiler Error:\ncannot return reference to local variable: return owned type instead\n\n## Fixed Code:", "output": "fn create() -> String { String::from(\"test\") }", "task_id": "borrow_checker_return_local_ref_146", "family": "borrow_checker", "pattern": "return_local_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn is_valid(res: Result<i32, &str>) -> bool { res.map(|x| x >= 0).unwrap_or(false) }\n```\n\n## Compiler Error:\nuse is_some_and/is_ok_and instead of map+unwrap_or\n\n## Fixed Code:", "output": "fn is_valid(res: Result<i32, &str>) -> bool { res.is_ok_and(|x| x >= 0) }", "task_id": "rust_2024_is_some_and_056", "family": "rust_2024", "pattern": "is_some_and"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::needless_collect)] fn count_positive(v: &[i32]) -> usize { let pos: Vec<&i32> = v.iter().filter(|x| **x > 0).collect(); pos.len() }\n```\n\n## Compiler Error:\nclippy::needless_collect: remove the unnecessary .collect() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn count_positive(v: &[i32]) -> usize { v.iter().filter(|x| **x > 0).count() }", "task_id": "clippy_suppression_no_suppress_needless_collect_005", "family": "clippy_suppression", "pattern": "no_suppress_needless_collect"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn unwrap_or_ret(opt: Option<i32>) -> i32 { match opt { Some(x) => x, None => return 0 } }\n```\n\n## Compiler Error:\nuse let-else pattern for early returns on None/Err\n\n## Fixed Code:", "output": "fn unwrap_or_ret(opt: Option<i32>) -> i32 { let Some(x) = opt else { return 0; }; x }", "task_id": "rust_2024_let_else_045", "family": "rust_2024", "pattern": "let_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::rc::Rc; fn send_to_thread<T: Send>(val: T) {} fn main() { let rc = Rc::new(5); send_to_thread(rc); }\n```\n\n## Compiler Error:\n`Rc` cannot be sent between threads safely: use Arc instead\n\n## Fixed Code:", "output": "use std::sync::Arc; fn send_to_thread<T: Send>(val: T) {} fn main() { let rc = Arc::new(5); send_to_thread(rc); }", "task_id": "trait_bounds_rc_not_send_083", "family": "trait_bounds", "pattern": "rc_not_send"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn read_num(s: &str) -> i32 { s.parse()? }\n```\n\n## Compiler Error:\nthe `?` operator can only be used in a function that returns `Result`\n\n## Fixed Code:", "output": "fn read_num(s: &str) -> Result<i32, std::num::ParseIntError> { Ok(s.parse()?) }", "task_id": "result_handling_question_mark_return_type_002", "family": "result_handling", "pattern": "question_mark_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Score { value: i32 } fn main() { let mut items = vec![Score { value: 3 }, Score { value: 1 }]; items.sort(); }\n```\n\n## Compiler Error:\nthe trait `Ord` is not implemented: add #[derive(PartialEq, Eq, PartialOrd, Ord)]\n\n## Fixed Code:", "output": "#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Score { value: i32 } fn main() { let mut items = vec![Score { value: 3 }, Score { value: 1 }]; items.sort(); }", "task_id": "trait_bounds_missing_ord_074", "family": "trait_bounds", "pattern": "missing_ord"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::fs; fn read_file(path: &str) -> String { fs::read_to_string(path) }\n```\n\n## Compiler Error:\nmismatched types: expected String, found Result: propagate with Result return type\n\n## Fixed Code:", "output": "use std::fs; fn read_file(path: &str) -> std::io::Result<String> { fs::read_to_string(path) }", "task_id": "result_handling_propagate_error_067", "family": "result_handling", "pattern": "propagate_error"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::new(); s.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut s = String::new(); s.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_060", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Counter { count: i32 } fn main() { let c = Counter { count: 0 }; c.count = 5; }\n```\n\n## Compiler Error:\ncannot assign to field of immutable binding: add mut\n\n## Fixed Code:", "output": "struct Counter { count: i32 } fn main() { let mut c = Counter { count: 0 }; c.count = 5; }", "task_id": "borrow_checker_immutable_field_131", "family": "borrow_checker", "pattern": "immutable_field"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Point { x: i32, y: i32 } fn main() { let a = Point { x: 1, y: 2 }; let b = Point { x: 1, y: 2 }; println!(\"{}\", a == b); }\n```\n\n## Compiler Error:\nbinary operation `==` cannot be applied: add #[derive(PartialEq)]\n\n## Fixed Code:", "output": "#[derive(PartialEq)] struct Point { x: i32, y: i32 } fn main() { let a = Point { x: 1, y: 2 }; let b = Point { x: 1, y: 2 }; println!(\"{}\", a == b); }", "task_id": "trait_bounds_missing_partial_eq_056", "family": "trait_bounds", "pattern": "missing_partial_eq"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", s); let _ = s; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let s = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", s); let _ = s.clone(); } }", "task_id": "borrow_checker_move_in_loop_084", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::from(\"hello\"); let t = s; println!(\"{}\", s); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let s = String::from(\"hello\"); let t = s.clone(); println!(\"{}\", s); }", "task_id": "borrow_checker_use_after_move_clone_008", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn read_num(s: &str) -> i32 { s.parse()? }\n```\n\n## Compiler Error:\nthe `?` operator can only be used in a function that returns `Result`\n\n## Fixed Code:", "output": "fn read_num(s: &str) -> Result<i32, std::num::ParseIntError> { Ok(s.parse()?) }", "task_id": "result_handling_question_mark_return_type_000", "family": "result_handling", "pattern": "question_mark_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Vec2 { a: i32, b: i32 } fn main() { let a = Vec2 { a: 1, b: 2 }; let b = Vec2 { a: 1, b: 2 }; println!(\"{}\", a == b); }\n```\n\n## Compiler Error:\nbinary operation `==` cannot be applied: add #[derive(PartialEq)]\n\n## Fixed Code:", "output": "#[derive(PartialEq)] struct Vec2 { a: i32, b: i32 } fn main() { let a = Vec2 { a: 1, b: 2 }; let b = Vec2 { a: 1, b: 2 }; println!(\"{}\", a == b); }", "task_id": "trait_bounds_missing_partial_eq_060", "family": "trait_bounds", "pattern": "missing_partial_eq"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn join(v: &Vec<String>) -> String { v.join(\", \") }\n```\n\n## Compiler Error:\nclippy::ptr_arg: use &[T] instead of &Vec<T> in function parameters\n\n## Fixed Code:", "output": "fn join(v: &[String]) -> String { v.join(\", \") }", "task_id": "rust_2024_slice_param_060", "family": "rust_2024", "pattern": "slice_param"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::needless_collect)] fn sum_doubled(v: &[i32]) -> i32 { let doubled: Vec<i32> = v.iter().map(|x| x * 2).collect(); doubled.into_iter().sum() }\n```\n\n## Compiler Error:\nclippy::needless_collect: remove the unnecessary .collect() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn sum_doubled(v: &[i32]) -> i32 { v.iter().map(|x| x * 2).sum() }", "task_id": "clippy_suppression_no_suppress_needless_collect_002", "family": "clippy_suppression", "pattern": "no_suppress_needless_collect"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(unused_must_use)] fn remove(path: &str) { std::fs::remove_file(path); }\n```\n\n## Compiler Error:\ndon't suppress unused Result: handle the error properly\n\n## Fixed Code:", "output": "fn remove(path: &str) -> std::io::Result<()> { std::fs::remove_file(path) }", "task_id": "clippy_suppression_no_suppress_must_use_030", "family": "clippy_suppression", "pattern": "no_suppress_must_use"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; let backup = items; println!(\"{:?}\", items); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let items = vec![1, 2, 3]; let backup = items.clone(); println!(\"{:?}\", items); }", "task_id": "borrow_checker_use_after_move_clone_018", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn handle_request(req: Request) -> Response { let auth = req.headers.get(\"Authorization\"); if auth.is_none() { return Response::unauthorized(); } let token = auth.unwrap(); if !verify_token(token) { return Response::forbidden(); } let body = req.body(); let data: Data = serde_json::from_str(body).unwrap(); let result = db::save(&data); match result { Ok(_) => Response::ok(), Err(e) => Response::error(e) } }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn authenticate(req: &Request) -> Result<&str, Response> { req.headers.get(\"Authorization\").filter(|t| verify_token(t)).ok_or_else(Response::unauthorized) } fn parse_body(req: &Request) -> Result<Data, Response> { serde_json::from_str(req.body()).map_err(|_| Response::bad_request()) } fn handle_request(req: Request) -> Response { let _token = match authenticate(&req) { Ok(t) => t, Err(r) => return r }; match parse_body(&req).and_then(|data| db::save(&data).map_err(|e| Response::error(e))) { Ok(_) => Response::ok(), Err(r) => r } }", "task_id": "complexity_decompose_long_function_003", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let content: String = std::fs::read_to_string(\"file.txt\"); println!(\"{}\", content); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Result: use match\n\n## Fixed Code:", "output": "fn main() { match std::fs::read_to_string(\"file.txt\") { Ok(content) => println!(\"{}\", content), Err(e) => println!(\"Error: {}\", e) } }", "task_id": "result_handling_match_result_051", "family": "result_handling", "pattern": "match_result"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::collections::HashMap; struct Key { id: i32 } fn main() { let mut map = HashMap::new(); map.insert(Key { id: 1 }, \"value\"); }\n```\n\n## Compiler Error:\nthe trait `Hash` is not implemented: add #[derive(Hash, PartialEq, Eq)]\n\n## Fixed Code:", "output": "use std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Key { id: i32 } fn main() { let mut map = HashMap::new(); map.insert(Key { id: 1 }, \"value\"); }", "task_id": "trait_bounds_missing_hash_062", "family": "trait_bounds", "pattern": "missing_hash"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let map = std::collections::HashMap::from([(\"key\", 1)]); let val = map.get(\"key\"); println!(\"{}\", val); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let map = std::collections::HashMap::from([(\"key\", 1)]); if let Some(val) = map.get(\"key\") { println!(\"{}\", val); } }", "task_id": "result_handling_if_let_option_039", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn make_vec() -> &Vec<i32> { let v = vec![1, 2, 3]; &v }\n```\n\n## Compiler Error:\ncannot return reference to local variable: return owned type instead\n\n## Fixed Code:", "output": "fn make_vec() -> Vec<i32> { vec![1, 2, 3] }", "task_id": "borrow_checker_return_local_ref_141", "family": "borrow_checker", "pattern": "return_local_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_or_default(s: &str) -> i32 { match s.parse() { Ok(n) => n, Err(_) => return -1 } }\n```\n\n## Compiler Error:\nuse let-else pattern for early returns on None/Err\n\n## Fixed Code:", "output": "fn parse_or_default(s: &str) -> i32 { let Ok(n) = s.parse() else { return -1; }; n }", "task_id": "rust_2024_let_else_048", "family": "rust_2024", "pattern": "let_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(unused_must_use)] fn write_file(path: &str) { std::fs::write(path, \"data\"); }\n```\n\n## Compiler Error:\ndon't suppress unused Result: handle the error properly\n\n## Fixed Code:", "output": "fn write_file(path: &str) { let _ = std::fs::write(path, \"data\"); }", "task_id": "clippy_suppression_no_suppress_must_use_028", "family": "clippy_suppression", "pattern": "no_suppress_must_use"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", data); let _ = data; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let data = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", data); let _ = data.clone(); } }", "task_id": "borrow_checker_move_in_loop_086", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::uninlined_format_args)] fn log(level: &str, msg: &str) { eprintln!(\"[{}] {}\", level, msg); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format args instead of suppressing\n\n## Fixed Code:", "output": "fn log(level: &str, msg: &str) { eprintln!(\"[{level}] {msg}\"); }", "task_id": "clippy_suppression_no_suppress_format_args_009", "family": "clippy_suppression", "pattern": "no_suppress_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn find_item(v: &[i32], target: i32) -> Result<i32, &str> { v.iter().find(|&&x| x == target).copied() }\n```\n\n## Compiler Error:\nmismatched types: use ok_or to convert Option to Result\n\n## Fixed Code:", "output": "fn find_item(v: &[i32], target: i32) -> Result<i32, &str> { v.iter().find(|&&x| x == target).copied().ok_or(\"not found\") }", "task_id": "result_handling_option_ok_or_023", "family": "result_handling", "pattern": "option_ok_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn double_all(v: &[i32]) -> Vec<i32> { v.iter().cloned().map(|x| x * 2).collect() }\n```\n\n## Compiler Error:\nclippy::cloned_instead_of_copied: use .copied() for Copy types\n\n## Fixed Code:", "output": "fn double_all(v: &[i32]) -> Vec<i32> { v.iter().copied().map(|x| x * 2).collect() }", "task_id": "rust_2024_iter_copied_023", "family": "rust_2024", "pattern": "iter_copied"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut data = vec![1, 2, 3]; let elem = &data[0]; data.push(4); println!(\"{}\", elem); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut data = vec![1, 2, 3]; let elem = data[0]; data.push(4); println!(\"{}\", elem); }", "task_id": "borrow_checker_mut_borrow_conflict_030", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn take(item: String) {} fn main() { let mut items = vec![String::from(\"a\")]; take(items[0]); }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn take(item: String) {} fn main() { let mut items = vec![String::from(\"a\")]; take(items.remove(0)); }", "task_id": "borrow_checker_move_out_of_index_115", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Point { x: i32 } fn main() { let p = Point { x: 0 }; p.x = 5; }\n```\n\n## Compiler Error:\ncannot assign to field of immutable binding: add mut\n\n## Fixed Code:", "output": "struct Point { x: i32 } fn main() { let mut p = Point { x: 0 }; p.x = 5; }", "task_id": "borrow_checker_immutable_field_132", "family": "borrow_checker", "pattern": "immutable_field"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn process(data: &str) -> Result<String, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } let parsed: i32 = trimmed.parse().map_err(|_| Error::Parse)?; let validated = if parsed < 0 { return Err(Error::Negative); } else { parsed }; let result = validated * 2 + 10; Ok(format!(\"result: {}\", result)) }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn parse_input(data: &str) -> Result<i32, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } trimmed.parse().map_err(|_| Error::Parse) } fn validate(n: i32) -> Result<i32, Error> { if n < 0 { Err(Error::Negative) } else { Ok(n) } } fn process(data: &str) -> Result<String, Error> { let parsed = parse_input(data)?; let validated = validate(parsed)?; Ok(format!(\"result: {}\", validated * 2 + 10)) }", "task_id": "complexity_decompose_long_function_000", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; for _ in 0..2 { let _ = items; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let items = vec![1, 2, 3]; for _ in 0..2 { let _ = items.clone(); } }", "task_id": "borrow_checker_move_in_loop_095", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::manual_map)] fn inc(opt: Option<i32>) -> Option<i32> { match opt { Some(x) => Some(x + 1), None => None } }\n```\n\n## Compiler Error:\nclippy::manual_map: use .map() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn inc(opt: Option<i32>) -> Option<i32> { opt.map(|x| x + 1) }", "task_id": "clippy_suppression_no_suppress_manual_map_012", "family": "clippy_suppression", "pattern": "no_suppress_manual_map"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Score { value: i32 } fn main() { let a = Score { value: 42 }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Score { value: i32 } fn main() { let a = Score { value: 42 }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_024", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let opt = Some(String::from(\"hi\")); match opt { Some(s) => println!(\"{}\", s), None => {} } println!(\"{:?}\", opt); }\n```\n\n## Compiler Error:\nborrow of moved value in match: match on reference instead\n\n## Fixed Code:", "output": "fn main() { let opt = Some(String::from(\"hi\")); match &opt { Some(s) => println!(\"{}\", s), None => {} } println!(\"{:?}\", opt); }", "task_id": "borrow_checker_match_move_102", "family": "borrow_checker", "pattern": "match_move"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn check(opt: Option<i32>) -> bool { if let Some(x) = opt { if x > 0 { return true; } } false }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn check(opt: Option<i32>) -> bool { if let Some(x) = opt && x > 0 { return true; } false }", "task_id": "rust_2024_let_chains_041", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn print_it<T>(val: T) { println!(\"{:?}\", val); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add trait bound T: Debug\n\n## Fixed Code:", "output": "fn print_it<T: std::fmt::Debug>(val: T) { println!(\"{:?}\", val); }", "task_id": "trait_bounds_missing_generic_bound_035", "family": "trait_bounds", "pattern": "missing_generic_bound"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn greet(who: &str) { println!(\"Hello, {}\", who); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn greet(who: &str) { println!(\"Hello, {who}\"); }", "task_id": "rust_2024_inline_format_args_002", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn is_digit(c: char) -> bool { match c { '0'..='9' => true, _ => false } }\n```\n\n## Compiler Error:\nclippy::match_like_matches_macro: use matches!() macro\n\n## Fixed Code:", "output": "fn is_digit(c: char) -> bool { matches!(c, '0'..='9') }", "task_id": "rust_2024_use_matches_macro_027", "family": "rust_2024", "pattern": "use_matches_macro"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(dead_code)] fn unused_helper() -> i32 { 42 } fn main() { println!(\"hello\"); }\n```\n\n## Compiler Error:\ndon't suppress dead_code: remove unused functions instead\n\n## Fixed Code:", "output": "fn main() { println!(\"hello\"); }", "task_id": "clippy_suppression_no_suppress_dead_code_033", "family": "clippy_suppression", "pattern": "no_suppress_dead_code"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn format_point(x: f64, y: f64) -> String { format!(\"({}, {})\", x, y) }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn format_point(x: f64, y: f64) -> String { format!(\"({x}, {y})\") }", "task_id": "rust_2024_inline_format_args_019", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::manual_map)] fn to_upper(opt: Option<String>) -> Option<String> { match opt { Some(s) => Some(s.to_uppercase()), None => None } }\n```\n\n## Compiler Error:\nclippy::manual_map: use .map() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn to_upper(opt: Option<String>) -> Option<String> { opt.map(|s| s.to_uppercase()) }", "task_id": "clippy_suppression_no_suppress_manual_map_016", "family": "clippy_suppression", "pattern": "no_suppress_manual_map"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let table = std::collections::HashMap::from([(\"key\", 1)]); let val = table.get(\"key\"); println!(\"{}\", val); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let table = std::collections::HashMap::from([(\"key\", 1)]); if let Some(val) = table.get(\"key\") { println!(\"{}\", val); } }", "task_id": "result_handling_if_let_option_043", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::needless_collect)] fn sum_doubled(v: &[i32]) -> i32 { let doubled: Vec<i32> = v.iter().map(|x| x * 2).collect(); doubled.into_iter().sum() }\n```\n\n## Compiler Error:\nclippy::needless_collect: remove the unnecessary .collect() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn sum_doubled(v: &[i32]) -> i32 { v.iter().map(|x| x * 2).sum() }", "task_id": "clippy_suppression_no_suppress_needless_collect_001", "family": "clippy_suppression", "pattern": "no_suppress_needless_collect"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Point { x: i32 } fn main() { let x = Point { x: 5 }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct Point { x: i32 } fn main() { let x = Point { x: 5 }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_008", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Rank { pos: i32 } fn main() { let mut items = vec![Rank { pos: 3 }, Rank { pos: 1 }]; items.sort(); }\n```\n\n## Compiler Error:\nthe trait `Ord` is not implemented: add #[derive(PartialEq, Eq, PartialOrd, Ord)]\n\n## Fixed Code:", "output": "#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Rank { pos: i32 } fn main() { let mut items = vec![Rank { pos: 3 }, Rank { pos: 1 }]; items.sort(); }", "task_id": "trait_bounds_missing_ord_076", "family": "trait_bounds", "pattern": "missing_ord"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::fs; fn read_file(path: &str) -> String { fs::read_to_string(path) }\n```\n\n## Compiler Error:\nmismatched types: expected String, found Result: propagate with Result return type\n\n## Fixed Code:", "output": "use std::fs; fn read_file(path: &str) -> std::io::Result<String> { fs::read_to_string(path) }", "task_id": "result_handling_propagate_error_068", "family": "result_handling", "pattern": "propagate_error"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let table = std::collections::HashMap::new(); table.insert(1, 2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut table = std::collections::HashMap::new(); table.insert(1, 2); }", "task_id": "borrow_checker_missing_mut_067", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut words = vec![\"a\".to_string(), \"b\".to_string()]; let copy = &words; words.push(\"c\".to_string()); println!(\"{:?}\", copy); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut words = vec![\"a\".to_string(), \"b\".to_string()]; let copy = words.clone(); words.push(\"c\".to_string()); println!(\"{:?}\", copy); }", "task_id": "borrow_checker_mut_borrow_conflict_042", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n// main.rs - everything inline\nmod config { pub struct Config { pub db_url: String } impl Config { pub fn load() -> Self { todo!() } } }\nmod db { pub fn connect(_url: &str) {} pub fn query() {} }\nmod handlers { pub fn index() {} pub fn health() {} }\nfn main() {}\n```\n\n## Compiler Error:\nfile too long: extract inline modules into separate files\n\n## Fixed Code:", "output": "// main.rs\nmod config;\nmod db;\nmod handlers;\n\nfn main() {}\n\n// config.rs\npub struct Config { pub db_url: String }\nimpl Config { pub fn load() -> Self { todo!() } }\n\n// db.rs\npub fn connect(_url: &str) {}\npub fn query() {}\n\n// handlers.rs\npub fn index() {}\npub fn health() {}", "task_id": "complexity_extract_modules_to_files_010", "family": "complexity", "pattern": "extract_modules_to_files"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![String::from(\"a\"), String::from(\"b\")]; let item = items[0]; }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn main() { let items = vec![String::from(\"a\"), String::from(\"b\")]; let item = items[0].clone(); }", "task_id": "borrow_checker_move_out_of_index_121", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Count { n: i32 } fn main() { let a = Count { n: 42 }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Count { n: i32 } fn main() { let a = Count { n: 42 }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_021", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Status { msg: String } fn main() { let m = Status { msg: \"hello\".into() }; println!(\"{}\", m); }\n```\n\n## Compiler Error:\ndoesn't implement `std::fmt::Display`: implement Display trait\n\n## Fixed Code:", "output": "use std::fmt; struct Status { msg: String } impl fmt::Display for Status { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"{}\", self.msg) } } fn main() { let m = Status { msg: \"hello\".into() }; println!(\"{}\", m); }", "task_id": "trait_bounds_missing_display_094", "family": "trait_bounds", "pattern": "missing_display"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let cache = std::collections::HashMap::from([(\"key\", 1)]); let val = cache.get(\"key\"); println!(\"{}\", val); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let cache = std::collections::HashMap::from([(\"key\", 1)]); if let Some(val) = cache.get(\"key\") { println!(\"{}\", val); } }", "task_id": "result_handling_if_let_option_047", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Options { limit: u32 } fn main() { let c: Options = Default::default(); }\n```\n\n## Compiler Error:\ndoesn't implement `Default`: add #[derive(Default)]\n\n## Fixed Code:", "output": "#[derive(Default)] struct Options { limit: u32 } fn main() { let c: Options = Default::default(); }", "task_id": "trait_bounds_missing_default_049", "family": "trait_bounds", "pattern": "missing_default"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn format_point(x: f64, y: f64) -> String { format!(\"({}, {})\", x, y) }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn format_point(x: f64, y: f64) -> String { format!(\"({x}, {y})\") }", "task_id": "rust_2024_inline_format_args_017", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::manual_map)] fn to_upper(opt: Option<String>) -> Option<String> { match opt { Some(s) => Some(s.to_uppercase()), None => None } }\n```\n\n## Compiler Error:\nclippy::manual_map: use .map() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn to_upper(opt: Option<String>) -> Option<String> { opt.map(|s| s.to_uppercase()) }", "task_id": "clippy_suppression_no_suppress_manual_map_017", "family": "clippy_suppression", "pattern": "no_suppress_manual_map"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; let copy = nums; println!(\"{:?}\", nums); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let nums = vec![1, 2, 3]; let copy = nums.clone(); println!(\"{:?}\", nums); }", "task_id": "borrow_checker_use_after_move_clone_017", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Pair { first: i32, second: i32 } fn main() { let a = Pair { first: 1, second: 2 }; let b = Pair { first: 1, second: 2 }; println!(\"{}\", a == b); }\n```\n\n## Compiler Error:\nbinary operation `==` cannot be applied: add #[derive(PartialEq)]\n\n## Fixed Code:", "output": "#[derive(PartialEq)] struct Pair { first: i32, second: i32 } fn main() { let a = Pair { first: 1, second: 2 }; let b = Pair { first: 1, second: 2 }; println!(\"{}\", a == b); }", "task_id": "trait_bounds_missing_partial_eq_061", "family": "trait_bounds", "pattern": "missing_partial_eq"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![String::from(\"a\"), String::from(\"b\")]; let item = items[0]; }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn main() { let items = vec![String::from(\"a\"), String::from(\"b\")]; let item = items[0].clone(); }", "task_id": "borrow_checker_move_out_of_index_124", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn clone_it<T>(val: T) -> T { val.clone() }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add trait bound T: Debug\n\n## Fixed Code:", "output": "fn clone_it<T: Clone>(val: T) -> T { val.clone() }", "task_id": "trait_bounds_missing_generic_bound_040", "family": "trait_bounds", "pattern": "missing_generic_bound"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let text = String::from(\"data\"); let moved = text; println!(\"{}\", moved); println!(\"{}\", text); }\n```\n\n## Compiler Error:\nborrow of moved value: reorder statements so use comes before move\n\n## Fixed Code:", "output": "fn main() { let text = String::from(\"data\"); println!(\"{}\", text); let moved = text; println!(\"{}\", moved); }", "task_id": "borrow_checker_use_after_move_reorder_021", "family": "borrow_checker", "pattern": "use_after_move_reorder"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::from(\"world\"); let taken = msg; println!(\"{}\", taken); println!(\"{}\", msg); }\n```\n\n## Compiler Error:\nborrow of moved value: reorder statements so use comes before move\n\n## Fixed Code:", "output": "fn main() { let msg = String::from(\"world\"); println!(\"{}\", msg); let taken = msg; println!(\"{}\", taken); }", "task_id": "borrow_checker_use_after_move_reorder_020", "family": "borrow_checker", "pattern": "use_after_move_reorder"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Message { text: String } fn main() { let m = Message { text: \"hello\".into() }; println!(\"{}\", m); }\n```\n\n## Compiler Error:\ndoesn't implement `std::fmt::Display`: implement Display trait\n\n## Fixed Code:", "output": "use std::fmt; struct Message { text: String } impl fmt::Display for Message { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"{}\", self.text) } } fn main() { let m = Message { text: \"hello\".into() }; println!(\"{}\", m); }", "task_id": "trait_bounds_missing_display_095", "family": "trait_bounds", "pattern": "missing_display"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn create() -> &String { let s = String::from(\"test\"); &s }\n```\n\n## Compiler Error:\ncannot return reference to local variable: return owned type instead\n\n## Fixed Code:", "output": "fn create() -> String { String::from(\"test\") }", "task_id": "borrow_checker_return_local_ref_145", "family": "borrow_checker", "pattern": "return_local_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Score { value: i32 } fn main() { let mut items = vec![Score { value: 3 }, Score { value: 1 }]; items.sort(); }\n```\n\n## Compiler Error:\nthe trait `Ord` is not implemented: add #[derive(PartialEq, Eq, PartialOrd, Ord)]\n\n## Fixed Code:", "output": "#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Score { value: i32 } fn main() { let mut items = vec![Score { value: 3 }, Score { value: 1 }]; items.sort(); }", "task_id": "trait_bounds_missing_ord_077", "family": "trait_bounds", "pattern": "missing_ord"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let text = String::new(); text.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut text = String::new(); text.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_061", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut nums = vec![1, 2, 3]; let head = &nums[0]; nums.push(4); println!(\"{}\", head); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut nums = vec![1, 2, 3]; let head = nums[0]; nums.push(4); println!(\"{}\", head); }", "task_id": "borrow_checker_mut_borrow_conflict_029", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = vec![String::from(\"a\"), String::from(\"b\")]; let elem = data[0]; }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn main() { let data = vec![String::from(\"a\"), String::from(\"b\")]; let elem = data[0].clone(); }", "task_id": "borrow_checker_move_out_of_index_122", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Data { value: String } fn main() { let a = Data { value: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Data { value: String } fn main() { let a = Data { value: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_010", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn double_parse(s: &str) -> i32 { s.parse::<i32>().map(|n| n * 2) }\n```\n\n## Compiler Error:\nmismatched types: function returns Result but body doesn't\n\n## Fixed Code:", "output": "fn double_parse(s: &str) -> Result<i32, std::num::ParseIntError> { s.parse::<i32>().map(|n| n * 2) }", "task_id": "result_handling_result_map_return_type_058", "family": "result_handling", "pattern": "result_map_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; let first = items.first(); println!(\"{}\", first); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let items = vec![1, 2, 3]; if let Some(first) = items.first() { println!(\"{}\", first); } }", "task_id": "result_handling_if_let_option_035", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let name = String::from(\"world\"); let copy = name; println!(\"{}\", name); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let name = String::from(\"world\"); let copy = name.clone(); println!(\"{}\", name); }", "task_id": "borrow_checker_use_after_move_clone_009", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn read_file(path: &str) -> String { std::fs::read_to_string(path)? }\n```\n\n## Compiler Error:\nthe `?` operator can only be used in a function that returns `Result`\n\n## Fixed Code:", "output": "fn read_file(path: &str) -> Result<String, std::io::Error> { Ok(std::fs::read_to_string(path)?) }", "task_id": "result_handling_question_mark_return_type_005", "family": "result_handling", "pattern": "question_mark_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Data { value: String } fn main() { let a = Data { value: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Data { value: String } fn main() { let a = Data { value: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_018", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::from(\"hello\"); let t = s; println!(\"{}\", s); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let s = String::from(\"hello\"); let t = s.clone(); println!(\"{}\", s); }", "task_id": "borrow_checker_use_after_move_clone_000", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut text = String::from(\"hello\"); let a = &mut text; let b = &mut text; println!(\"{} {}\", a, b); }\n```\n\n## Compiler Error:\ncannot borrow as mutable more than once at a time\n\n## Fixed Code:", "output": "fn main() { let mut text = String::from(\"hello\"); let a = &mut text; println!(\"{}\", a); let b = &mut text; println!(\"{}\", b); }", "task_id": "borrow_checker_double_mut_borrow_082", "family": "borrow_checker", "pattern": "double_mut_borrow"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Config { timeout: u32 } fn main() { let c: Config = Default::default(); }\n```\n\n## Compiler Error:\ndoesn't implement `Default`: add #[derive(Default)]\n\n## Fixed Code:", "output": "#[derive(Default)] struct Config { timeout: u32 } fn main() { let c: Config = Default::default(); }", "task_id": "trait_bounds_missing_default_044", "family": "trait_bounds", "pattern": "missing_default"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn log(text: &str, level: u32) { eprintln!(\"[{}] {}\", level, text); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn log(text: &str, level: u32) { eprintln!(\"[{level}] {text}\"); }", "task_id": "rust_2024_inline_format_args_012", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn has_positive(opt: Option<i32>) -> bool { opt.map(|x| x > 0).unwrap_or(false) }\n```\n\n## Compiler Error:\nuse is_some_and/is_ok_and instead of map+unwrap_or\n\n## Fixed Code:", "output": "fn has_positive(opt: Option<i32>) -> bool { opt.is_some_and(|x| x > 0) }", "task_id": "rust_2024_is_some_and_052", "family": "rust_2024", "pattern": "is_some_and"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let n: i32 = \"42\".parse()?; println!(\"{}\", n); }\n```\n\n## Compiler Error:\nthe `?` operator in main needs `fn main() -> Result<...>`\n\n## Fixed Code:", "output": "fn main() -> Result<(), Box<dyn std::error::Error>> { let n: i32 = \"42\".parse()?; println!(\"{}\", n); Ok(()) }", "task_id": "result_handling_main_question_mark_026", "family": "result_handling", "pattern": "main_question_mark"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct User { id: u32 } fn main() { let x = User { id: 1 }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct User { id: u32 } fn main() { let x = User { id: 1 }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_005", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; v.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut v = vec![1, 2, 3]; v.push(4); }", "task_id": "borrow_checker_missing_mut_054", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_env(key: &str) -> Result<String, &str> { std::env::var(key) }\n```\n\n## Compiler Error:\nmismatched types: expected Result, use map_err to convert\n\n## Fixed Code:", "output": "fn get_env(key: &str) -> Result<String, &str> { std::env::var(key).map_err(|_| \"not found\") }", "task_id": "result_handling_option_to_result_map_err_014", "family": "result_handling", "pattern": "option_to_result_map_err"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", msg); let _ = msg; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let msg = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", msg); let _ = msg.clone(); } }", "task_id": "borrow_checker_move_in_loop_091", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn last_elem(v: &[i32]) -> i32 { *v.last() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn last_elem(v: &[i32]) -> i32 { *v.last().unwrap_or(&0) }", "task_id": "result_handling_option_unwrap_or_011", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn is_valid(res: Result<i32, &str>) -> bool { res.map(|x| x >= 0).unwrap_or(false) }\n```\n\n## Compiler Error:\nuse is_some_and/is_ok_and instead of map+unwrap_or\n\n## Fixed Code:", "output": "fn is_valid(res: Result<i32, &str>) -> bool { res.is_ok_and(|x| x >= 0) }", "task_id": "rust_2024_is_some_and_055", "family": "rust_2024", "pattern": "is_some_and"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let name = String::from(\"world\"); let copy = name; println!(\"{}\", name); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let name = String::from(\"world\"); let copy = name.clone(); println!(\"{}\", name); }", "task_id": "borrow_checker_use_after_move_clone_001", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(dead_code)] fn unused_helper() -> i32 { 42 } fn main() { println!(\"hello\"); }\n```\n\n## Compiler Error:\ndon't suppress dead_code: remove unused functions instead\n\n## Fixed Code:", "output": "fn main() { println!(\"hello\"); }", "task_id": "clippy_suppression_no_suppress_dead_code_035", "family": "clippy_suppression", "pattern": "no_suppress_dead_code"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut data = String::from(\"hello\"); let x = &mut data; let y = &mut data; println!(\"{} {}\", x, y); }\n```\n\n## Compiler Error:\ncannot borrow as mutable more than once at a time\n\n## Fixed Code:", "output": "fn main() { let mut data = String::from(\"hello\"); let x = &mut data; println!(\"{}\", x); let y = &mut data; println!(\"{}\", y); }", "task_id": "borrow_checker_double_mut_borrow_080", "family": "borrow_checker", "pattern": "double_mut_borrow"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Priority { level: i32 } fn main() { let mut items = vec![Priority { level: 3 }, Priority { level: 1 }]; items.sort(); }\n```\n\n## Compiler Error:\nthe trait `Ord` is not implemented: add #[derive(PartialEq, Eq, PartialOrd, Ord)]\n\n## Fixed Code:", "output": "#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Priority { level: i32 } fn main() { let mut items = vec![Priority { level: 3 }, Priority { level: 1 }]; items.sort(); }", "task_id": "trait_bounds_missing_ord_075", "family": "trait_bounds", "pattern": "missing_ord"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn format_point(lat: f64, lon: f64) -> String { format!(\"({}, {})\", lat, lon) }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn format_point(lat: f64, lon: f64) -> String { format!(\"({lat}, {lon})\") }", "task_id": "rust_2024_inline_format_args_016", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct App { db_host: String, db_port: u16, db_name: String, cache_host: String, cache_port: u16, log_level: String, log_file: String, server_host: String, server_port: u16 }\n```\n\n## Compiler Error:\nstruct has too many fields: decompose into smaller focused types\n\n## Fixed Code:", "output": "struct DbConfig { host: String, port: u16, name: String }\nstruct CacheConfig { host: String, port: u16 }\nstruct LogConfig { level: String, file: String }\nstruct ServerConfig { host: String, port: u16 }\nstruct App { db: DbConfig, cache: CacheConfig, log: LogConfig, server: ServerConfig }", "task_id": "complexity_decompose_god_struct_013", "family": "complexity", "pattern": "decompose_god_struct"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn sum_squares(v: &[i32]) -> i32 { v.iter().map(|x| x * x).collect::<Vec<_>>().into_iter().sum() }\n```\n\n## Compiler Error:\nclippy::needless_collect: remove unnecessary intermediate collect()\n\n## Fixed Code:", "output": "fn sum_squares(v: &[i32]) -> i32 { v.iter().map(|x| x * x).sum() }", "task_id": "rust_2024_remove_needless_collect_037", "family": "rust_2024", "pattern": "remove_needless_collect"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(unused_must_use)] fn write_file(path: &str) { std::fs::write(path, \"data\"); }\n```\n\n## Compiler Error:\ndon't suppress unused Result: handle the error properly\n\n## Fixed Code:", "output": "fn write_file(path: &str) { let _ = std::fs::write(path, \"data\"); }", "task_id": "clippy_suppression_no_suppress_must_use_027", "family": "clippy_suppression", "pattern": "no_suppress_must_use"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn double_all(v: &[i32]) -> Vec<i32> { v.iter().cloned().map(|x| x * 2).collect() }\n```\n\n## Compiler Error:\nclippy::cloned_instead_of_copied: use .copied() for Copy types\n\n## Fixed Code:", "output": "fn double_all(v: &[i32]) -> Vec<i32> { v.iter().copied().map(|x| x * 2).collect() }", "task_id": "rust_2024_iter_copied_021", "family": "rust_2024", "pattern": "iter_copied"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::new(); msg.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut msg = String::new(); msg.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_058", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let name = String::from(\"world\"); let copy = name; println!(\"{}\", name); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let name = String::from(\"world\"); let copy = name.clone(); println!(\"{}\", name); }", "task_id": "borrow_checker_use_after_move_clone_005", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; let first = items.first(); println!(\"{}\", first); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let items = vec![1, 2, 3]; if let Some(first) = items.first() { println!(\"{}\", first); } }", "task_id": "result_handling_if_let_option_038", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = vec![String::from(\"a\"), String::from(\"b\")]; let elem = data[0]; }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn main() { let data = vec![String::from(\"a\"), String::from(\"b\")]; let elem = data[0].clone(); }", "task_id": "borrow_checker_move_out_of_index_128", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let n: i32 = \"42\".parse()?; println!(\"{}\", n); }\n```\n\n## Compiler Error:\nthe `?` operator in main needs `fn main() -> Result<...>`\n\n## Fixed Code:", "output": "fn main() -> Result<(), Box<dyn std::error::Error>> { let n: i32 = \"42\".parse()?; println!(\"{}\", n); Ok(()) }", "task_id": "result_handling_main_question_mark_025", "family": "result_handling", "pattern": "main_question_mark"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Message { text: String } fn main() { let m = Message { text: \"hello\".into() }; println!(\"{}\", m); }\n```\n\n## Compiler Error:\ndoesn't implement `std::fmt::Display`: implement Display trait\n\n## Fixed Code:", "output": "use std::fmt; struct Message { text: String } impl fmt::Display for Message { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"{}\", self.text) } } fn main() { let m = Message { text: \"hello\".into() }; println!(\"{}\", m); }", "task_id": "trait_bounds_missing_display_092", "family": "trait_bounds", "pattern": "missing_display"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Settings { retries: u32 } fn main() { let c: Settings = Default::default(); }\n```\n\n## Compiler Error:\ndoesn't implement `Default`: add #[derive(Default)]\n\n## Fixed Code:", "output": "#[derive(Default)] struct Settings { retries: u32 } fn main() { let c: Settings = Default::default(); }", "task_id": "trait_bounds_missing_default_048", "family": "trait_bounds", "pattern": "missing_default"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Config { timeout: u32 } fn main() { let c: Config = Default::default(); }\n```\n\n## Compiler Error:\ndoesn't implement `Default`: add #[derive(Default)]\n\n## Fixed Code:", "output": "#[derive(Default)] struct Config { timeout: u32 } fn main() { let c: Config = Default::default(); }", "task_id": "trait_bounds_missing_default_050", "family": "trait_bounds", "pattern": "missing_default"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut nums = vec![1, 2, 3]; let head = &nums[0]; nums.push(4); println!(\"{}\", head); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut nums = vec![1, 2, 3]; let head = nums[0]; nums.push(4); println!(\"{}\", head); }", "task_id": "borrow_checker_mut_borrow_conflict_032", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn sum_squares(v: &[i32]) -> i32 { v.iter().map(|x| x * x).collect::<Vec<_>>().into_iter().sum() }\n```\n\n## Compiler Error:\nclippy::needless_collect: remove unnecessary intermediate collect()\n\n## Fixed Code:", "output": "fn sum_squares(v: &[i32]) -> i32 { v.iter().map(|x| x * x).sum() }", "task_id": "rust_2024_remove_needless_collect_038", "family": "rust_2024", "pattern": "remove_needless_collect"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn check(opt: Option<i32>) -> bool { if let Some(x) = opt { if x > 0 { return true; } } false }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn check(opt: Option<i32>) -> bool { if let Some(x) = opt && x > 0 { return true; } false }", "task_id": "rust_2024_let_chains_040", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut s = String::from(\"hello\"); let r1 = &mut s; let r2 = &mut s; println!(\"{} {}\", r1, r2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable more than once at a time\n\n## Fixed Code:", "output": "fn main() { let mut s = String::from(\"hello\"); let r1 = &mut s; println!(\"{}\", r1); let r2 = &mut s; println!(\"{}\", r2); }", "task_id": "borrow_checker_double_mut_borrow_078", "family": "borrow_checker", "pattern": "double_mut_borrow"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::new(); s.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut s = String::new(); s.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_056", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let text = String::from(\"data\"); let moved = text; println!(\"{}\", moved); println!(\"{}\", text); }\n```\n\n## Compiler Error:\nborrow of moved value: reorder statements so use comes before move\n\n## Fixed Code:", "output": "fn main() { let text = String::from(\"data\"); println!(\"{}\", text); let moved = text; println!(\"{}\", moved); }", "task_id": "borrow_checker_use_after_move_reorder_024", "family": "borrow_checker", "pattern": "use_after_move_reorder"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; v.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut v = vec![1, 2, 3]; v.push(4); }", "task_id": "borrow_checker_missing_mut_046", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn first_char(s: &str) -> char { s.chars().next() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn first_char(s: &str) -> char { s.chars().next().unwrap_or(' ') }", "task_id": "result_handling_option_unwrap_or_007", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_int(s: &str) -> Result<i32, &str> { s.parse() }\n```\n\n## Compiler Error:\nmismatched types: expected Result, use map_err to convert\n\n## Fixed Code:", "output": "fn parse_int(s: &str) -> Result<i32, &str> { s.parse().map_err(|_| \"parse error\") }", "task_id": "result_handling_option_to_result_map_err_015", "family": "result_handling", "pattern": "option_to_result_map_err"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let table = std::collections::HashMap::new(); table.insert(1, 2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut table = std::collections::HashMap::new(); table.insert(1, 2); }", "task_id": "borrow_checker_missing_mut_070", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::manual_map)] fn inc(opt: Option<i32>) -> Option<i32> { match opt { Some(x) => Some(x + 1), None => None } }\n```\n\n## Compiler Error:\nclippy::manual_map: use .map() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn inc(opt: Option<i32>) -> Option<i32> { opt.map(|x| x + 1) }", "task_id": "clippy_suppression_no_suppress_manual_map_013", "family": "clippy_suppression", "pattern": "no_suppress_manual_map"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn has_positive(opt: Option<i32>) -> bool { opt.map(|x| x > 0).unwrap_or(false) }\n```\n\n## Compiler Error:\nuse is_some_and/is_ok_and instead of map+unwrap_or\n\n## Fixed Code:", "output": "fn has_positive(opt: Option<i32>) -> bool { opt.is_some_and(|x| x > 0) }", "task_id": "rust_2024_is_some_and_051", "family": "rust_2024", "pattern": "is_some_and"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Vec2 { a: i32, b: i32 } fn main() { let a = Vec2 { a: 1, b: 2 }; let b = Vec2 { a: 1, b: 2 }; println!(\"{}\", a == b); }\n```\n\n## Compiler Error:\nbinary operation `==` cannot be applied: add #[derive(PartialEq)]\n\n## Fixed Code:", "output": "#[derive(PartialEq)] struct Vec2 { a: i32, b: i32 } fn main() { let a = Vec2 { a: 1, b: 2 }; let b = Vec2 { a: 1, b: 2 }; println!(\"{}\", a == b); }", "task_id": "trait_bounds_missing_partial_eq_057", "family": "trait_bounds", "pattern": "missing_partial_eq"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let content: String = std::fs::read_to_string(\"file.txt\"); println!(\"{}\", content); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Result: use match\n\n## Fixed Code:", "output": "fn main() { match std::fs::read_to_string(\"file.txt\") { Ok(content) => println!(\"{}\", content), Err(e) => println!(\"Error: {}\", e) } }", "task_id": "result_handling_match_result_053", "family": "result_handling", "pattern": "match_result"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Priority { level: i32 } fn main() { let mut items = vec![Priority { level: 3 }, Priority { level: 1 }]; items.sort(); }\n```\n\n## Compiler Error:\nthe trait `Ord` is not implemented: add #[derive(PartialEq, Eq, PartialOrd, Ord)]\n\n## Fixed Code:", "output": "#[derive(PartialEq, Eq, PartialOrd, Ord)] struct Priority { level: i32 } fn main() { let mut items = vec![Priority { level: 3 }, Priority { level: 1 }]; items.sort(); }", "task_id": "trait_bounds_missing_ord_072", "family": "trait_bounds", "pattern": "missing_ord"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_add(s: &str) -> i32 { s.parse::<i32>().map(|n| n + 1) }\n```\n\n## Compiler Error:\nmismatched types: function returns Result but body doesn't\n\n## Fixed Code:", "output": "fn parse_add(s: &str) -> Result<i32, std::num::ParseIntError> { s.parse::<i32>().map(|n| n + 1) }", "task_id": "result_handling_result_map_return_type_054", "family": "result_handling", "pattern": "result_map_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Counter { count: i32 } fn main() { let c = Counter { count: 0 }; c.count = 5; }\n```\n\n## Compiler Error:\ncannot assign to field of immutable binding: add mut\n\n## Fixed Code:", "output": "struct Counter { count: i32 } fn main() { let mut c = Counter { count: 0 }; c.count = 5; }", "task_id": "borrow_checker_immutable_field_134", "family": "borrow_checker", "pattern": "immutable_field"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; let first = v.first(); println!(\"{}\", first); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let v = vec![1, 2, 3]; if let Some(first) = v.first() { println!(\"{}\", first); } }", "task_id": "result_handling_if_let_option_030", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn has_positive(opt: Option<i32>) -> bool { opt.map(|x| x > 0).unwrap_or(false) }\n```\n\n## Compiler Error:\nuse is_some_and/is_ok_and instead of map+unwrap_or\n\n## Fixed Code:", "output": "fn has_positive(opt: Option<i32>) -> bool { opt.is_some_and(|x| x > 0) }", "task_id": "rust_2024_is_some_and_053", "family": "rust_2024", "pattern": "is_some_and"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![String::from(\"a\"), String::from(\"b\")]; let first = v[0]; }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn main() { let v = vec![String::from(\"a\"), String::from(\"b\")]; let first = v[0].clone(); }", "task_id": "borrow_checker_move_out_of_index_126", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n// lib.rs with too many functions\npub fn create_user() {} pub fn get_user() {} pub fn update_user() {} pub fn delete_user() {} pub fn list_users() {} pub fn create_post() {} pub fn get_post() {} pub fn update_post() {} pub fn delete_post() {} pub fn list_posts() {} pub fn create_comment() {} pub fn get_comment() {}\n```\n\n## Compiler Error:\ntoo many functions in module: split into focused submodules\n\n## Fixed Code:", "output": "// lib.rs\npub mod users;\npub mod posts;\npub mod comments;\n\n// users.rs\npub fn create() {} pub fn get() {} pub fn update() {} pub fn delete() {} pub fn list() {}\n\n// posts.rs\npub fn create() {} pub fn get() {} pub fn update() {} pub fn delete() {} pub fn list() {}\n\n// comments.rs\npub fn create() {} pub fn get() {}", "task_id": "complexity_split_large_module_007", "family": "complexity", "pattern": "split_large_module"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn sum_all(v: &[i64]) -> i64 { v.iter().cloned().sum() }\n```\n\n## Compiler Error:\nclippy::cloned_instead_of_copied: use .copied() for Copy types\n\n## Fixed Code:", "output": "fn sum_all(v: &[i64]) -> i64 { v.iter().copied().sum() }", "task_id": "rust_2024_iter_copied_025", "family": "rust_2024", "pattern": "iter_copied"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let table = std::collections::HashMap::new(); table.insert(1, 2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut table = std::collections::HashMap::new(); table.insert(1, 2); }", "task_id": "borrow_checker_missing_mut_073", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::rc::Rc; fn send_to_thread<T: Send>(val: T) {} fn main() { let shared = Rc::new(5); send_to_thread(shared); }\n```\n\n## Compiler Error:\n`Rc` cannot be sent between threads safely: use Arc instead\n\n## Fixed Code:", "output": "use std::sync::Arc; fn send_to_thread<T: Send>(val: T) {} fn main() { let shared = Arc::new(5); send_to_thread(shared); }", "task_id": "trait_bounds_rc_not_send_087", "family": "trait_bounds", "pattern": "rc_not_send"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Pair { first: i32, second: i32 } fn main() { let a = Pair { first: 1, second: 2 }; let b = Pair { first: 1, second: 2 }; println!(\"{}\", a == b); }\n```\n\n## Compiler Error:\nbinary operation `==` cannot be applied: add #[derive(PartialEq)]\n\n## Fixed Code:", "output": "#[derive(PartialEq)] struct Pair { first: i32, second: i32 } fn main() { let a = Pair { first: 1, second: 2 }; let b = Pair { first: 1, second: 2 }; println!(\"{}\", a == b); }", "task_id": "trait_bounds_missing_partial_eq_055", "family": "trait_bounds", "pattern": "missing_partial_eq"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn last_elem(v: &[i32]) -> i32 { *v.last() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn last_elem(v: &[i32]) -> i32 { *v.last().unwrap_or(&0) }", "task_id": "result_handling_option_unwrap_or_010", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn format_point(x: f64, y: f64) -> String { format!(\"({}, {})\", x, y) }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn format_point(x: f64, y: f64) -> String { format!(\"({x}, {y})\") }", "task_id": "rust_2024_inline_format_args_015", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::clone_on_ref_ptr)] fn share(a: &std::sync::Arc<String>) -> std::sync::Arc<String> { a.clone() }\n```\n\n## Compiler Error:\nclippy::clone_on_ref_ptr: use Arc::clone() for clarity instead of suppressing\n\n## Fixed Code:", "output": "fn share(a: &std::sync::Arc<String>) -> std::sync::Arc<String> { std::sync::Arc::clone(a) }", "task_id": "clippy_suppression_no_suppress_clone_ref_023", "family": "clippy_suppression", "pattern": "no_suppress_clone_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let map = std::collections::HashMap::from([(\"key\", 1)]); let val = map.get(\"key\"); println!(\"{}\", val); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let map = std::collections::HashMap::from([(\"key\", 1)]); if let Some(val) = map.get(\"key\") { println!(\"{}\", val); } }", "task_id": "result_handling_if_let_option_045", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let opt = Some(String::from(\"hi\")); match opt { Some(s) => println!(\"{}\", s), None => {} } println!(\"{:?}\", opt); }\n```\n\n## Compiler Error:\nborrow of moved value in match: match on reference instead\n\n## Fixed Code:", "output": "fn main() { let opt = Some(String::from(\"hi\")); match &opt { Some(s) => println!(\"{}\", s), None => {} } println!(\"{:?}\", opt); }", "task_id": "borrow_checker_match_move_108", "family": "borrow_checker", "pattern": "match_move"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut data = vec![1, 2, 3]; let elem = &data[0]; data.push(4); println!(\"{}\", elem); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut data = vec![1, 2, 3]; let elem = data[0]; data.push(4); println!(\"{}\", elem); }", "task_id": "borrow_checker_mut_borrow_conflict_033", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Counter { count: i32 } fn main() { let c = Counter { count: 0 }; c.count = 5; }\n```\n\n## Compiler Error:\ncannot assign to field of immutable binding: add mut\n\n## Fixed Code:", "output": "struct Counter { count: i32 } fn main() { let mut c = Counter { count: 0 }; c.count = 5; }", "task_id": "borrow_checker_immutable_field_137", "family": "borrow_checker", "pattern": "immutable_field"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Pair { first: i32, second: i32 } fn main() { let a = Pair { first: 1, second: 2 }; let b = Pair { first: 1, second: 2 }; println!(\"{}\", a == b); }\n```\n\n## Compiler Error:\nbinary operation `==` cannot be applied: add #[derive(PartialEq)]\n\n## Fixed Code:", "output": "#[derive(PartialEq)] struct Pair { first: i32, second: i32 } fn main() { let a = Pair { first: 1, second: 2 }; let b = Pair { first: 1, second: 2 }; println!(\"{}\", a == b); }", "task_id": "trait_bounds_missing_partial_eq_058", "family": "trait_bounds", "pattern": "missing_partial_eq"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Data { value: String } fn main() { let a = Data { value: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Data { value: String } fn main() { let a = Data { value: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_014", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn join(v: &Vec<String>) -> String { v.join(\", \") }\n```\n\n## Compiler Error:\nclippy::ptr_arg: use &[T] instead of &Vec<T> in function parameters\n\n## Fixed Code:", "output": "fn join(v: &[String]) -> String { v.join(\", \") }", "task_id": "rust_2024_slice_param_061", "family": "rust_2024", "pattern": "slice_param"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn take(s: String) {} fn main() { let mut v = vec![String::from(\"a\")]; take(v[0]); }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn take(s: String) {} fn main() { let mut v = vec![String::from(\"a\")]; take(v.remove(0)); }", "task_id": "borrow_checker_move_out_of_index_117", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut v = vec![1, 2, 3]; let first = &v[0]; v.push(4); println!(\"{}\", first); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut v = vec![1, 2, 3]; let first = v[0]; v.push(4); println!(\"{}\", first); }", "task_id": "borrow_checker_mut_borrow_conflict_028", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Item { name: String } fn main() { let a = Item { name: String::from(\"x\") }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Item { name: String } fn main() { let a = Item { name: String::from(\"x\") }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_019", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn unwrap_or_ret(opt: Option<i32>) -> i32 { match opt { Some(x) => x, None => return 0 } }\n```\n\n## Compiler Error:\nuse let-else pattern for early returns on None/Err\n\n## Fixed Code:", "output": "fn unwrap_or_ret(opt: Option<i32>) -> i32 { let Some(x) = opt else { return 0; }; x }", "task_id": "rust_2024_let_else_046", "family": "rust_2024", "pattern": "let_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let table = std::collections::HashMap::from([(\"key\", 1)]); let val = table.get(\"key\"); println!(\"{}\", val); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let table = std::collections::HashMap::from([(\"key\", 1)]); if let Some(val) = table.get(\"key\") { println!(\"{}\", val); } }", "task_id": "result_handling_if_let_option_040", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct App { db_host: String, db_port: u16, db_name: String, cache_host: String, cache_port: u16, log_level: String, log_file: String, server_host: String, server_port: u16 }\n```\n\n## Compiler Error:\nstruct has too many fields: decompose into smaller focused types\n\n## Fixed Code:", "output": "struct DbConfig { host: String, port: u16, name: String }\nstruct CacheConfig { host: String, port: u16 }\nstruct LogConfig { level: String, file: String }\nstruct ServerConfig { host: String, port: u16 }\nstruct App { db: DbConfig, cache: CacheConfig, log: LogConfig, server: ServerConfig }", "task_id": "complexity_decompose_god_struct_014", "family": "complexity", "pattern": "decompose_god_struct"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_str() -> &str { let s = String::from(\"hello\"); &s }\n```\n\n## Compiler Error:\ncannot return reference to local variable: return owned type instead\n\n## Fixed Code:", "output": "fn get_str() -> String { String::from(\"hello\") }", "task_id": "borrow_checker_return_local_ref_138", "family": "borrow_checker", "pattern": "return_local_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn greet(user: &str) { println!(\"Hello, {}\", user); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn greet(user: &str) { println!(\"Hello, {user}\"); }", "task_id": "rust_2024_inline_format_args_001", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Message { text: String } fn main() { let m = Message { text: \"hello\".into() }; println!(\"{}\", m); }\n```\n\n## Compiler Error:\ndoesn't implement `std::fmt::Display`: implement Display trait\n\n## Fixed Code:", "output": "use std::fmt; struct Message { text: String } impl fmt::Display for Message { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"{}\", self.text) } } fn main() { let m = Message { text: \"hello\".into() }; println!(\"{}\", m); }", "task_id": "trait_bounds_missing_display_089", "family": "trait_bounds", "pattern": "missing_display"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(unused_must_use)] fn remove(path: &str) { std::fs::remove_file(path); }\n```\n\n## Compiler Error:\ndon't suppress unused Result: handle the error properly\n\n## Fixed Code:", "output": "fn remove(path: &str) -> std::io::Result<()> { std::fs::remove_file(path) }", "task_id": "clippy_suppression_no_suppress_must_use_032", "family": "clippy_suppression", "pattern": "no_suppress_must_use"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n// main.rs - everything inline\nmod config { pub struct Config { pub db_url: String } impl Config { pub fn load() -> Self { todo!() } } }\nmod db { pub fn connect(_url: &str) {} pub fn query() {} }\nmod handlers { pub fn index() {} pub fn health() {} }\nfn main() {}\n```\n\n## Compiler Error:\nfile too long: extract inline modules into separate files\n\n## Fixed Code:", "output": "// main.rs\nmod config;\nmod db;\nmod handlers;\n\nfn main() {}\n\n// config.rs\npub struct Config { pub db_url: String }\nimpl Config { pub fn load() -> Self { todo!() } }\n\n// db.rs\npub fn connect(_url: &str) {}\npub fn query() {}\n\n// handlers.rs\npub fn index() {}\npub fn health() {}", "task_id": "complexity_extract_modules_to_files_009", "family": "complexity", "pattern": "extract_modules_to_files"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let content = std::fs::read_to_string(\"data.txt\")?; println!(\"{}\", content); }\n```\n\n## Compiler Error:\nthe `?` operator in main needs `fn main() -> Result<...>`\n\n## Fixed Code:", "output": "fn main() -> Result<(), Box<dyn std::error::Error>> { let content = std::fs::read_to_string(\"data.txt\")?; println!(\"{}\", content); Ok(()) }", "task_id": "result_handling_main_question_mark_028", "family": "result_handling", "pattern": "main_question_mark"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", s); let _ = s; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let s = String::from(\"hello\"); for _ in 0..3 { println!(\"{}\", s); let _ = s.clone(); } }", "task_id": "borrow_checker_move_in_loop_087", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(dead_code)] fn unused_helper() -> i32 { 42 } fn main() { println!(\"hello\"); }\n```\n\n## Compiler Error:\ndon't suppress dead_code: remove unused functions instead\n\n## Fixed Code:", "output": "fn main() { println!(\"hello\"); }", "task_id": "clippy_suppression_no_suppress_dead_code_034", "family": "clippy_suppression", "pattern": "no_suppress_dead_code"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::fs; fn read_file(path: &str) -> String { fs::read_to_string(path) }\n```\n\n## Compiler Error:\nmismatched types: expected String, found Result: propagate with Result return type\n\n## Fixed Code:", "output": "use std::fs; fn read_file(path: &str) -> std::io::Result<String> { fs::read_to_string(path) }", "task_id": "result_handling_propagate_error_066", "family": "result_handling", "pattern": "propagate_error"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut data = vec![1, 2, 3]; let elem = &data[0]; data.push(4); println!(\"{}\", elem); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut data = vec![1, 2, 3]; let elem = data[0]; data.push(4); println!(\"{}\", elem); }", "task_id": "borrow_checker_mut_borrow_conflict_036", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::manual_map)] fn inc(opt: Option<i32>) -> Option<i32> { match opt { Some(x) => Some(x + 1), None => None } }\n```\n\n## Compiler Error:\nclippy::manual_map: use .map() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn inc(opt: Option<i32>) -> Option<i32> { opt.map(|x| x + 1) }", "task_id": "clippy_suppression_no_suppress_manual_map_014", "family": "clippy_suppression", "pattern": "no_suppress_manual_map"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Rect { width: i32 } fn main() { let r = Rect { width: 0 }; r.width = 5; }\n```\n\n## Compiler Error:\ncannot assign to field of immutable binding: add mut\n\n## Fixed Code:", "output": "struct Rect { width: i32 } fn main() { let mut r = Rect { width: 0 }; r.width = 5; }", "task_id": "borrow_checker_immutable_field_136", "family": "borrow_checker", "pattern": "immutable_field"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#![allow(clippy::all)] fn add(a: i32, b: i32) -> i32 { let result: i32 = a + b; return result; }\n```\n\n## Compiler Error:\nnever use blanket #[allow(clippy::all)]: fix the specific issues instead\n\n## Fixed Code:", "output": "fn add(a: i32, b: i32) -> i32 { a + b }", "task_id": "clippy_suppression_no_blanket_suppress_026", "family": "clippy_suppression", "pattern": "no_blanket_suppress"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let item = Some(String::from(\"hi\")); match item { Some(x) => println!(\"{}\", x), None => {} } println!(\"{:?}\", item); }\n```\n\n## Compiler Error:\nborrow of moved value in match: match on reference instead\n\n## Fixed Code:", "output": "fn main() { let item = Some(String::from(\"hi\")); match &item { Some(x) => println!(\"{}\", x), None => {} } println!(\"{:?}\", item); }", "task_id": "borrow_checker_match_move_107", "family": "borrow_checker", "pattern": "match_move"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Amount { qty: i32 } fn double(n: Amount) -> i32 { n.qty * 2 } fn main() { let n = Amount { qty: 5 }; println!(\"{} {}\", double(n), double(n)); }\n```\n\n## Compiler Error:\nuse of moved value: add #[derive(Clone, Copy)]\n\n## Fixed Code:", "output": "#[derive(Clone, Copy)] struct Amount { qty: i32 } fn double(n: Amount) -> i32 { n.qty * 2 } fn main() { let n = Amount { qty: 5 }; println!(\"{} {}\", double(n), double(n)); }", "task_id": "trait_bounds_missing_copy_034", "family": "trait_bounds", "pattern": "missing_copy"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn compare<T>(a: T, b: T) -> bool { a == b }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add trait bound T: Debug\n\n## Fixed Code:", "output": "fn compare<T: PartialEq>(a: T, b: T) -> bool { a == b }", "task_id": "trait_bounds_missing_generic_bound_042", "family": "trait_bounds", "pattern": "missing_generic_bound"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut data = String::from(\"hello\"); let x = &mut data; let y = &mut data; println!(\"{} {}\", x, y); }\n```\n\n## Compiler Error:\ncannot borrow as mutable more than once at a time\n\n## Fixed Code:", "output": "fn main() { let mut data = String::from(\"hello\"); let x = &mut data; println!(\"{}\", x); let y = &mut data; println!(\"{}\", y); }", "task_id": "borrow_checker_double_mut_borrow_083", "family": "borrow_checker", "pattern": "double_mut_borrow"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn clone_it<T>(val: T) -> T { val.clone() }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add trait bound T: Debug\n\n## Fixed Code:", "output": "fn clone_it<T: Clone>(val: T) -> T { val.clone() }", "task_id": "trait_bounds_missing_generic_bound_039", "family": "trait_bounds", "pattern": "missing_generic_bound"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::uninlined_format_args)] fn greet(name: &str) { println!(\"Hello, {}\", name); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format args instead of suppressing\n\n## Fixed Code:", "output": "fn greet(name: &str) { println!(\"Hello, {name}\"); }", "task_id": "clippy_suppression_no_suppress_format_args_008", "family": "clippy_suppression", "pattern": "no_suppress_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::rc::Rc; fn send_to_thread<T: Send>(val: T) {} fn main() { let ptr = Rc::new(5); send_to_thread(ptr); }\n```\n\n## Compiler Error:\n`Rc` cannot be sent between threads safely: use Arc instead\n\n## Fixed Code:", "output": "use std::sync::Arc; fn send_to_thread<T: Send>(val: T) {} fn main() { let ptr = Arc::new(5); send_to_thread(ptr); }", "task_id": "trait_bounds_rc_not_send_085", "family": "trait_bounds", "pattern": "rc_not_send"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn sum_squares(v: &[i32]) -> i32 { v.iter().map(|x| x * x).collect::<Vec<_>>().into_iter().sum() }\n```\n\n## Compiler Error:\nclippy::needless_collect: remove unnecessary intermediate collect()\n\n## Fixed Code:", "output": "fn sum_squares(v: &[i32]) -> i32 { v.iter().map(|x| x * x).sum() }", "task_id": "rust_2024_remove_needless_collect_036", "family": "rust_2024", "pattern": "remove_needless_collect"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn is_ok(r: &Result<i32, &str>) -> bool { match r { Ok(_) => true, _ => false } }\n```\n\n## Compiler Error:\nclippy::match_like_matches_macro: use matches!() macro\n\n## Fixed Code:", "output": "fn is_ok(r: &Result<i32, &str>) -> bool { matches!(r, Ok(_)) }", "task_id": "rust_2024_use_matches_macro_030", "family": "rust_2024", "pattern": "use_matches_macro"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; nums.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut nums = vec![1, 2, 3]; nums.push(4); }", "task_id": "borrow_checker_missing_mut_051", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn sum(v: &Vec<i32>) -> i32 { v.iter().sum() }\n```\n\n## Compiler Error:\nclippy::ptr_arg: use &[T] instead of &Vec<T> in function parameters\n\n## Fixed Code:", "output": "fn sum(v: &[i32]) -> i32 { v.iter().sum() }", "task_id": "rust_2024_slice_param_057", "family": "rust_2024", "pattern": "slice_param"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn format_point(lat: f64, lon: f64) -> String { format!(\"({}, {})\", lat, lon) }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn format_point(lat: f64, lon: f64) -> String { format!(\"({lat}, {lon})\") }", "task_id": "rust_2024_inline_format_args_018", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct User { id: u32 } fn main() { let x = User { id: 1 }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct User { id: u32 } fn main() { let x = User { id: 1 }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_001", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn take(val: String) {} fn main() { let mut data = vec![String::from(\"a\")]; take(data[0]); }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn take(val: String) {} fn main() { let mut data = vec![String::from(\"a\")]; take(data.remove(0)); }", "task_id": "borrow_checker_move_out_of_index_116", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::clone_on_ref_ptr)] fn share(a: &std::sync::Arc<String>) -> std::sync::Arc<String> { a.clone() }\n```\n\n## Compiler Error:\nclippy::clone_on_ref_ptr: use Arc::clone() for clarity instead of suppressing\n\n## Fixed Code:", "output": "fn share(a: &std::sync::Arc<String>) -> std::sync::Arc<String> { std::sync::Arc::clone(a) }", "task_id": "clippy_suppression_no_suppress_clone_ref_021", "family": "clippy_suppression", "pattern": "no_suppress_clone_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::from(\"world\"); let taken = msg; println!(\"{}\", taken); println!(\"{}\", msg); }\n```\n\n## Compiler Error:\nborrow of moved value: reorder statements so use comes before move\n\n## Fixed Code:", "output": "fn main() { let msg = String::from(\"world\"); println!(\"{}\", msg); let taken = msg; println!(\"{}\", taken); }", "task_id": "borrow_checker_use_after_move_reorder_023", "family": "borrow_checker", "pattern": "use_after_move_reorder"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut nums = vec![1, 2, 3]; let head = &nums[0]; nums.push(4); println!(\"{}\", head); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut nums = vec![1, 2, 3]; let head = nums[0]; nums.push(4); println!(\"{}\", head); }", "task_id": "borrow_checker_mut_borrow_conflict_035", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn greet(user: &str) { println!(\"Hello, {}\", user); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn greet(user: &str) { println!(\"Hello, {user}\"); }", "task_id": "rust_2024_inline_format_args_007", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; for _ in 0..2 { let _ = items; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let items = vec![1, 2, 3]; for _ in 0..2 { let _ = items.clone(); } }", "task_id": "borrow_checker_move_in_loop_098", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let n: i32 = \"abc\".parse(); println!(\"{}\", n); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Result: use match\n\n## Fixed Code:", "output": "fn main() { match \"abc\".parse::<i32>() { Ok(n) => println!(\"{}\", n), Err(e) => println!(\"Error: {}\", e) } }", "task_id": "result_handling_match_result_050", "family": "result_handling", "pattern": "match_result"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn clone_it<T>(val: T) -> T { val.clone() }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add trait bound T: Debug\n\n## Fixed Code:", "output": "fn clone_it<T: Clone>(val: T) -> T { val.clone() }", "task_id": "trait_bounds_missing_generic_bound_038", "family": "trait_bounds", "pattern": "missing_generic_bound"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::fs; fn read_bytes(path: &str) -> Vec<u8> { fs::read(path) }\n```\n\n## Compiler Error:\nmismatched types: expected String, found Result: propagate with Result return type\n\n## Fixed Code:", "output": "use std::fs; fn read_bytes(path: &str) -> std::io::Result<Vec<u8>> { fs::read(path) }", "task_id": "result_handling_propagate_error_071", "family": "result_handling", "pattern": "propagate_error"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::needless_collect)] fn count_positive(v: &[i32]) -> usize { let pos: Vec<&i32> = v.iter().filter(|x| **x > 0).collect(); pos.len() }\n```\n\n## Compiler Error:\nclippy::needless_collect: remove the unnecessary .collect() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn count_positive(v: &[i32]) -> usize { v.iter().filter(|x| **x > 0).count() }", "task_id": "clippy_suppression_no_suppress_needless_collect_004", "family": "clippy_suppression", "pattern": "no_suppress_needless_collect"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Item { count: usize } fn main() { let x = Item { count: 10 }; println!(\"{:?}\", x); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add #[derive(Debug)]\n\n## Fixed Code:", "output": "#[derive(Debug)] struct Item { count: usize } fn main() { let x = Item { count: 10 }; println!(\"{:?}\", x); }", "task_id": "trait_bounds_missing_debug_003", "family": "trait_bounds", "pattern": "missing_debug"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; let first = nums.first(); println!(\"{}\", first); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let nums = vec![1, 2, 3]; if let Some(first) = nums.first() { println!(\"{}\", first); } }", "task_id": "result_handling_if_let_option_037", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut v = vec![\"a\".to_string(), \"b\".to_string()]; let snapshot = &v; v.push(\"c\".to_string()); println!(\"{:?}\", snapshot); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut v = vec![\"a\".to_string(), \"b\".to_string()]; let snapshot = v.clone(); v.push(\"c\".to_string()); println!(\"{:?}\", snapshot); }", "task_id": "borrow_checker_mut_borrow_conflict_040", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Options { limit: u32 } fn main() { let c: Options = Default::default(); }\n```\n\n## Compiler Error:\ndoesn't implement `Default`: add #[derive(Default)]\n\n## Fixed Code:", "output": "#[derive(Default)] struct Options { limit: u32 } fn main() { let c: Options = Default::default(); }", "task_id": "trait_bounds_missing_default_046", "family": "trait_bounds", "pattern": "missing_default"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let buf = String::new(); buf.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut buf = String::new(); buf.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_063", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let content = std::fs::read_to_string(\"data.txt\")?; println!(\"{}\", content); }\n```\n\n## Compiler Error:\nthe `?` operator in main needs `fn main() -> Result<...>`\n\n## Fixed Code:", "output": "fn main() -> Result<(), Box<dyn std::error::Error>> { let content = std::fs::read_to_string(\"data.txt\")?; println!(\"{}\", content); Ok(()) }", "task_id": "result_handling_main_question_mark_029", "family": "result_handling", "pattern": "main_question_mark"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::rc::Rc; fn send_to_thread<T: Send>(val: T) {} fn main() { let ptr = Rc::new(5); send_to_thread(ptr); }\n```\n\n## Compiler Error:\n`Rc` cannot be sent between threads safely: use Arc instead\n\n## Fixed Code:", "output": "use std::sync::Arc; fn send_to_thread<T: Send>(val: T) {} fn main() { let ptr = Arc::new(5); send_to_thread(ptr); }", "task_id": "trait_bounds_rc_not_send_088", "family": "trait_bounds", "pattern": "rc_not_send"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn format_point(lat: f64, lon: f64) -> String { format!(\"({}, {})\", lat, lon) }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn format_point(lat: f64, lon: f64) -> String { format!(\"({lat}, {lon})\") }", "task_id": "rust_2024_inline_format_args_020", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let s = String::from(\"hello\"); let t = s; println!(\"{}\", t); println!(\"{}\", s); }\n```\n\n## Compiler Error:\nborrow of moved value: reorder statements so use comes before move\n\n## Fixed Code:", "output": "fn main() { let s = String::from(\"hello\"); println!(\"{}\", s); let t = s; println!(\"{}\", t); }", "task_id": "borrow_checker_use_after_move_reorder_022", "family": "borrow_checker", "pattern": "use_after_move_reorder"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Point { x: i32 } fn main() { let p = Point { x: 0 }; p.x = 5; }\n```\n\n## Compiler Error:\ncannot assign to field of immutable binding: add mut\n\n## Fixed Code:", "output": "struct Point { x: i32 } fn main() { let mut p = Point { x: 0 }; p.x = 5; }", "task_id": "borrow_checker_immutable_field_135", "family": "borrow_checker", "pattern": "immutable_field"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_or_make(opt: Option<String>) -> String { opt.unwrap_or(generate()) } fn generate() -> String { String::from(\"default\") }\n```\n\n## Compiler Error:\nunnecessary eager evaluation: use unwrap_or_else for lazy default\n\n## Fixed Code:", "output": "fn get_or_make(opt: Option<String>) -> String { opt.unwrap_or_else(generate) } fn generate() -> String { String::from(\"default\") }", "task_id": "result_handling_unwrap_or_else_064", "family": "result_handling", "pattern": "unwrap_or_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Num { v: i32 } fn double(n: Num) -> i32 { n.v * 2 } fn main() { let n = Num { v: 5 }; println!(\"{} {}\", double(n), double(n)); }\n```\n\n## Compiler Error:\nuse of moved value: add #[derive(Clone, Copy)]\n\n## Fixed Code:", "output": "#[derive(Clone, Copy)] struct Num { v: i32 } fn double(n: Num) -> i32 { n.v * 2 } fn main() { let n = Num { v: 5 }; println!(\"{} {}\", double(n), double(n)); }", "task_id": "trait_bounds_missing_copy_029", "family": "trait_bounds", "pattern": "missing_copy"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn print_it<T>(val: T) { println!(\"{:?}\", val); }\n```\n\n## Compiler Error:\ndoesn't implement `Debug`: add trait bound T: Debug\n\n## Fixed Code:", "output": "fn print_it<T: std::fmt::Debug>(val: T) { println!(\"{:?}\", val); }", "task_id": "trait_bounds_missing_generic_bound_036", "family": "trait_bounds", "pattern": "missing_generic_bound"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = vec![1, 2, 3]; data.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut data = vec![1, 2, 3]; data.push(4); }", "task_id": "borrow_checker_missing_mut_049", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Config { timeout: u32 } fn main() { let c: Config = Default::default(); }\n```\n\n## Compiler Error:\ndoesn't implement `Default`: add #[derive(Default)]\n\n## Fixed Code:", "output": "#[derive(Default)] struct Config { timeout: u32 } fn main() { let c: Config = Default::default(); }", "task_id": "trait_bounds_missing_default_047", "family": "trait_bounds", "pattern": "missing_default"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn sum(v: &Vec<i32>) -> i32 { v.iter().sum() }\n```\n\n## Compiler Error:\nclippy::ptr_arg: use &[T] instead of &Vec<T> in function parameters\n\n## Fixed Code:", "output": "fn sum(v: &[i32]) -> i32 { v.iter().sum() }", "task_id": "rust_2024_slice_param_059", "family": "rust_2024", "pattern": "slice_param"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn handle_request(req: Request) -> Response { let auth = req.headers.get(\"Authorization\"); if auth.is_none() { return Response::unauthorized(); } let token = auth.unwrap(); if !verify_token(token) { return Response::forbidden(); } let body = req.body(); let data: Data = serde_json::from_str(body).unwrap(); let result = db::save(&data); match result { Ok(_) => Response::ok(), Err(e) => Response::error(e) } }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn authenticate(req: &Request) -> Result<&str, Response> { req.headers.get(\"Authorization\").filter(|t| verify_token(t)).ok_or_else(Response::unauthorized) } fn parse_body(req: &Request) -> Result<Data, Response> { serde_json::from_str(req.body()).map_err(|_| Response::bad_request()) } fn handle_request(req: Request) -> Response { let _token = match authenticate(&req) { Ok(t) => t, Err(r) => return r }; match parse_body(&req).and_then(|data| db::save(&data).map_err(|e| Response::error(e))) { Ok(_) => Response::ok(), Err(r) => r } }", "task_id": "complexity_decompose_long_function_005", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Count { n: i32 } fn main() { let a = Count { n: 42 }; let b = a.clone(); }\n```\n\n## Compiler Error:\nno method named `clone` found: add #[derive(Clone)]\n\n## Fixed Code:", "output": "#[derive(Clone)] struct Count { n: i32 } fn main() { let a = Count { n: 42 }; let b = a.clone(); }", "task_id": "trait_bounds_missing_clone_025", "family": "trait_bounds", "pattern": "missing_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let item = Some(String::from(\"hi\")); match item { Some(x) => println!(\"{}\", x), None => {} } println!(\"{:?}\", item); }\n```\n\n## Compiler Error:\nborrow of moved value in match: match on reference instead\n\n## Fixed Code:", "output": "fn main() { let item = Some(String::from(\"hi\")); match &item { Some(x) => println!(\"{}\", x), None => {} } println!(\"{:?}\", item); }", "task_id": "borrow_checker_match_move_110", "family": "borrow_checker", "pattern": "match_move"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut text = String::from(\"hello\"); let a = &mut text; let b = &mut text; println!(\"{} {}\", a, b); }\n```\n\n## Compiler Error:\ncannot borrow as mutable more than once at a time\n\n## Fixed Code:", "output": "fn main() { let mut text = String::from(\"hello\"); let a = &mut text; println!(\"{}\", a); let b = &mut text; println!(\"{}\", b); }", "task_id": "borrow_checker_double_mut_borrow_079", "family": "borrow_checker", "pattern": "double_mut_borrow"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt { if !s.is_empty() { return Some(s); } } None }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt && !s.is_empty() { return Some(s); } None }", "task_id": "rust_2024_let_chains_043", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nstruct Coord { x: i32 } fn double(n: Coord) -> i32 { n.x * 2 } fn main() { let n = Coord { x: 5 }; println!(\"{} {}\", double(n), double(n)); }\n```\n\n## Compiler Error:\nuse of moved value: add #[derive(Clone, Copy)]\n\n## Fixed Code:", "output": "#[derive(Clone, Copy)] struct Coord { x: i32 } fn double(n: Coord) -> i32 { n.x * 2 } fn main() { let n = Coord { x: 5 }; println!(\"{} {}\", double(n), double(n)); }", "task_id": "trait_bounds_missing_copy_027", "family": "trait_bounds", "pattern": "missing_copy"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn join(v: &Vec<String>) -> String { v.join(\", \") }\n```\n\n## Compiler Error:\nclippy::ptr_arg: use &[T] instead of &Vec<T> in function parameters\n\n## Fixed Code:", "output": "fn join(v: &[String]) -> String { v.join(\", \") }", "task_id": "rust_2024_slice_param_062", "family": "rust_2024", "pattern": "slice_param"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn greet(user: &str) { println!(\"Hello, {}\", user); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn greet(user: &str) { println!(\"Hello, {user}\"); }", "task_id": "rust_2024_inline_format_args_004", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut s = String::from(\"hello\"); let r1 = &mut s; let r2 = &mut s; println!(\"{} {}\", r1, r2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable more than once at a time\n\n## Fixed Code:", "output": "fn main() { let mut s = String::from(\"hello\"); let r1 = &mut s; println!(\"{}\", r1); let r2 = &mut s; println!(\"{}\", r2); }", "task_id": "borrow_checker_double_mut_borrow_081", "family": "borrow_checker", "pattern": "double_mut_borrow"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_somes(v: Vec<Option<i32>>) -> Vec<i32> { v.into_iter().filter(|x| x.is_some()).map(|x| x.unwrap()).collect() }\n```\n\n## Compiler Error:\nclippy::manual_flatten: use .flatten() instead of filter+unwrap\n\n## Fixed Code:", "output": "fn get_somes(v: Vec<Option<i32>>) -> Vec<i32> { v.into_iter().flatten().collect() }", "task_id": "rust_2024_use_flatten_035", "family": "rust_2024", "pattern": "use_flatten"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let msg = String::from(\"foo\"); let saved = msg; println!(\"{}\", msg); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let msg = String::from(\"foo\"); let saved = msg.clone(); println!(\"{}\", msg); }", "task_id": "borrow_checker_use_after_move_clone_003", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn make_vec() -> &Vec<i32> { let v = vec![1, 2, 3]; &v }\n```\n\n## Compiler Error:\ncannot return reference to local variable: return owned type instead\n\n## Fixed Code:", "output": "fn make_vec() -> Vec<i32> { vec![1, 2, 3] }", "task_id": "borrow_checker_return_local_ref_142", "family": "borrow_checker", "pattern": "return_local_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn parse_add(s: &str) -> i32 { s.parse::<i32>().map(|n| n + 1) }\n```\n\n## Compiler Error:\nmismatched types: function returns Result but body doesn't\n\n## Fixed Code:", "output": "fn parse_add(s: &str) -> Result<i32, std::num::ParseIntError> { s.parse::<i32>().map(|n| n + 1) }", "task_id": "result_handling_result_map_return_type_056", "family": "result_handling", "pattern": "result_map_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::rc::Rc; fn send_to_thread<T: Send>(val: T) {} fn main() { let ptr = Rc::new(5); send_to_thread(ptr); }\n```\n\n## Compiler Error:\n`Rc` cannot be sent between threads safely: use Arc instead\n\n## Fixed Code:", "output": "use std::sync::Arc; fn send_to_thread<T: Send>(val: T) {} fn main() { let ptr = Arc::new(5); send_to_thread(ptr); }", "task_id": "trait_bounds_rc_not_send_082", "family": "trait_bounds", "pattern": "rc_not_send"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn take(item: String) {} fn main() { let mut items = vec![String::from(\"a\")]; take(items[0]); }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn take(item: String) {} fn main() { let mut items = vec![String::from(\"a\")]; take(items.remove(0)); }", "task_id": "borrow_checker_move_out_of_index_112", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::collections::HashMap; struct Index { pos: i32 } fn main() { let mut map = HashMap::new(); map.insert(Index { pos: 1 }, \"value\"); }\n```\n\n## Compiler Error:\nthe trait `Hash` is not implemented: add #[derive(Hash, PartialEq, Eq)]\n\n## Fixed Code:", "output": "use std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Index { pos: i32 } fn main() { let mut map = HashMap::new(); map.insert(Index { pos: 1 }, \"value\"); }", "task_id": "trait_bounds_missing_hash_067", "family": "trait_bounds", "pattern": "missing_hash"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn process(data: &str) -> Result<String, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } let parsed: i32 = trimmed.parse().map_err(|_| Error::Parse)?; let validated = if parsed < 0 { return Err(Error::Negative); } else { parsed }; let result = validated * 2 + 10; Ok(format!(\"result: {}\", result)) }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn parse_input(data: &str) -> Result<i32, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } trimmed.parse().map_err(|_| Error::Parse) } fn validate(n: i32) -> Result<i32, Error> { if n < 0 { Err(Error::Negative) } else { Ok(n) } } fn process(data: &str) -> Result<String, Error> { let parsed = parse_input(data)?; let validated = validate(parsed)?; Ok(format!(\"result: {}\", validated * 2 + 10)) }", "task_id": "complexity_decompose_long_function_002", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn greet(name: &str) { println!(\"Hello, {}\", name); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn greet(name: &str) { println!(\"Hello, {name}\"); }", "task_id": "rust_2024_inline_format_args_006", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::manual_map)] fn to_upper(opt: Option<String>) -> Option<String> { match opt { Some(s) => Some(s.to_uppercase()), None => None } }\n```\n\n## Compiler Error:\nclippy::manual_map: use .map() instead of suppressing the lint\n\n## Fixed Code:", "output": "fn to_upper(opt: Option<String>) -> Option<String> { opt.map(|s| s.to_uppercase()) }", "task_id": "clippy_suppression_no_suppress_manual_map_015", "family": "clippy_suppression", "pattern": "no_suppress_manual_map"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn log(msg: &str, code: u32) { eprintln!(\"[{}] {}\", code, msg); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format variables\n\n## Fixed Code:", "output": "fn log(msg: &str, code: u32) { eprintln!(\"[{code}] {msg}\"); }", "task_id": "rust_2024_inline_format_args_013", "family": "rust_2024", "pattern": "inline_format_args"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; for _ in 0..2 { let _ = items; } }\n```\n\n## Compiler Error:\nuse of moved value in loop: clone inside the loop body\n\n## Fixed Code:", "output": "fn main() { let items = vec![1, 2, 3]; for _ in 0..2 { let _ = items.clone(); } }", "task_id": "borrow_checker_move_in_loop_101", "family": "borrow_checker", "pattern": "move_in_loop"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let map = std::collections::HashMap::from([(\"key\", 1)]); let val = map.get(\"key\"); println!(\"{}\", val); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let map = std::collections::HashMap::from([(\"key\", 1)]); if let Some(val) = map.get(\"key\") { println!(\"{}\", val); } }", "task_id": "result_handling_if_let_option_042", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; let w = v; println!(\"{:?}\", v); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let v = vec![1, 2, 3]; let w = v.clone(); println!(\"{:?}\", v); }", "task_id": "borrow_checker_use_after_move_clone_013", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_or_make(opt: Option<String>) -> String { opt.unwrap_or(generate()) } fn generate() -> String { String::from(\"default\") }\n```\n\n## Compiler Error:\nunnecessary eager evaluation: use unwrap_or_else for lazy default\n\n## Fixed Code:", "output": "fn get_or_make(opt: Option<String>) -> String { opt.unwrap_or_else(generate) } fn generate() -> String { String::from(\"default\") }", "task_id": "result_handling_unwrap_or_else_063", "family": "result_handling", "pattern": "unwrap_or_else"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_env(key: &str) -> Result<String, &str> { std::env::var(key) }\n```\n\n## Compiler Error:\nmismatched types: expected Result, use map_err to convert\n\n## Fixed Code:", "output": "fn get_env(key: &str) -> Result<String, &str> { std::env::var(key).map_err(|_| \"not found\") }", "task_id": "result_handling_option_to_result_map_err_013", "family": "result_handling", "pattern": "option_to_result_map_err"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn take(val: String) {} fn main() { let mut data = vec![String::from(\"a\")]; take(data[0]); }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn take(val: String) {} fn main() { let mut data = vec![String::from(\"a\")]; take(data.remove(0)); }", "task_id": "borrow_checker_move_out_of_index_119", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn take(s: String) {} fn main() { let mut v = vec![String::from(\"a\")]; take(v[0]); }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn take(s: String) {} fn main() { let mut v = vec![String::from(\"a\")]; take(v.remove(0)); }", "task_id": "borrow_checker_move_out_of_index_111", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; nums.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut nums = vec![1, 2, 3]; nums.push(4); }", "task_id": "borrow_checker_missing_mut_047", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; let backup = items; println!(\"{:?}\", items); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let items = vec![1, 2, 3]; let backup = items.clone(); println!(\"{:?}\", items); }", "task_id": "borrow_checker_use_after_move_clone_015", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let v = vec![1, 2, 3]; let w = v; println!(\"{:?}\", v); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let v = vec![1, 2, 3]; let w = v.clone(); println!(\"{:?}\", v); }", "task_id": "borrow_checker_use_after_move_clone_016", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nuse std::collections::HashMap; struct Tag { code: i32 } fn main() { let mut map = HashMap::new(); map.insert(Tag { code: 1 }, \"value\"); }\n```\n\n## Compiler Error:\nthe trait `Hash` is not implemented: add #[derive(Hash, PartialEq, Eq)]\n\n## Fixed Code:", "output": "use std::collections::HashMap; #[derive(Hash, PartialEq, Eq)] struct Tag { code: i32 } fn main() { let mut map = HashMap::new(); map.insert(Tag { code: 1 }, \"value\"); }", "task_id": "trait_bounds_missing_hash_069", "family": "trait_bounds", "pattern": "missing_hash"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn double_parse(s: &str) -> i32 { s.parse::<i32>().map(|n| n * 2) }\n```\n\n## Compiler Error:\nmismatched types: function returns Result but body doesn't\n\n## Fixed Code:", "output": "fn double_parse(s: &str) -> Result<i32, std::num::ParseIntError> { s.parse::<i32>().map(|n| n * 2) }", "task_id": "result_handling_result_map_return_type_057", "family": "result_handling", "pattern": "result_map_return_type"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let mut items = vec![\"a\".to_string(), \"b\".to_string()]; let saved = &items; items.push(\"c\".to_string()); println!(\"{:?}\", saved); }\n```\n\n## Compiler Error:\ncannot borrow as mutable because it is also borrowed as immutable\n\n## Fixed Code:", "output": "fn main() { let mut items = vec![\"a\".to_string(), \"b\".to_string()]; let saved = items.clone(); items.push(\"c\".to_string()); println!(\"{:?}\", saved); }", "task_id": "borrow_checker_mut_borrow_conflict_044", "family": "borrow_checker", "pattern": "mut_borrow_conflict"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let nums = vec![1, 2, 3]; let first = nums.first(); println!(\"{}\", first); }\n```\n\n## Compiler Error:\nmismatched types: expected integer, found Option: use if let\n\n## Fixed Code:", "output": "fn main() { let nums = vec![1, 2, 3]; if let Some(first) = nums.first() { println!(\"{}\", first); } }", "task_id": "result_handling_if_let_option_034", "family": "result_handling", "pattern": "if_let_option"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n// main.rs - everything inline\nmod config { pub struct Config { pub db_url: String } impl Config { pub fn load() -> Self { todo!() } } }\nmod db { pub fn connect(_url: &str) {} pub fn query() {} }\nmod handlers { pub fn index() {} pub fn health() {} }\nfn main() {}\n```\n\n## Compiler Error:\nfile too long: extract inline modules into separate files\n\n## Fixed Code:", "output": "// main.rs\nmod config;\nmod db;\nmod handlers;\n\nfn main() {}\n\n// config.rs\npub struct Config { pub db_url: String }\nimpl Config { pub fn load() -> Self { todo!() } }\n\n// db.rs\npub fn connect(_url: &str) {}\npub fn query() {}\n\n// handlers.rs\npub fn index() {}\npub fn health() {}", "task_id": "complexity_extract_modules_to_files_011", "family": "complexity", "pattern": "extract_modules_to_files"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(unused_must_use)] fn write_file(path: &str) { std::fs::write(path, \"data\"); }\n```\n\n## Compiler Error:\ndon't suppress unused Result: handle the error properly\n\n## Fixed Code:", "output": "fn write_file(path: &str) { let _ = std::fs::write(path, \"data\"); }", "task_id": "clippy_suppression_no_suppress_must_use_029", "family": "clippy_suppression", "pattern": "no_suppress_must_use"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; items.push(4); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut items = vec![1, 2, 3]; items.push(4); }", "task_id": "borrow_checker_missing_mut_052", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn sum_all(v: &[i64]) -> i64 { v.iter().cloned().sum() }\n```\n\n## Compiler Error:\nclippy::cloned_instead_of_copied: use .copied() for Copy types\n\n## Fixed Code:", "output": "fn sum_all(v: &[i64]) -> i64 { v.iter().copied().sum() }", "task_id": "rust_2024_iter_copied_024", "family": "rust_2024", "pattern": "iter_copied"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let cache = std::collections::HashMap::new(); cache.insert(1, 2); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut cache = std::collections::HashMap::new(); cache.insert(1, 2); }", "task_id": "borrow_checker_missing_mut_071", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn take(s: String) {} fn main() { let mut v = vec![String::from(\"a\")]; take(v[0]); }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn take(s: String) {} fn main() { let mut v = vec![String::from(\"a\")]; take(v.remove(0)); }", "task_id": "borrow_checker_move_out_of_index_114", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let data = vec![String::from(\"a\"), String::from(\"b\")]; let elem = data[0]; }\n```\n\n## Compiler Error:\ncannot move out of index of Vec: use .remove() or .clone()\n\n## Fixed Code:", "output": "fn main() { let data = vec![String::from(\"a\"), String::from(\"b\")]; let elem = data[0].clone(); }", "task_id": "borrow_checker_move_out_of_index_125", "family": "borrow_checker", "pattern": "move_out_of_index"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_str() -> &str { let s = String::from(\"hello\"); &s }\n```\n\n## Compiler Error:\ncannot return reference to local variable: return owned type instead\n\n## Fixed Code:", "output": "fn get_str() -> String { String::from(\"hello\") }", "task_id": "borrow_checker_return_local_ref_140", "family": "borrow_checker", "pattern": "return_local_ref"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn sum_all(v: &[i64]) -> i64 { v.iter().cloned().sum() }\n```\n\n## Compiler Error:\nclippy::cloned_instead_of_copied: use .copied() for Copy types\n\n## Fixed Code:", "output": "fn sum_all(v: &[i64]) -> i64 { v.iter().copied().sum() }", "task_id": "rust_2024_iter_copied_026", "family": "rust_2024", "pattern": "iter_copied"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let items = vec![1, 2, 3]; let backup = items; println!(\"{:?}\", items); }\n```\n\n## Compiler Error:\nborrow of moved value: use .clone() before the move\n\n## Fixed Code:", "output": "fn main() { let items = vec![1, 2, 3]; let backup = items.clone(); println!(\"{:?}\", items); }", "task_id": "borrow_checker_use_after_move_clone_012", "family": "borrow_checker", "pattern": "use_after_move_clone"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn main() { let text = String::new(); text.push_str(\"hello\"); }\n```\n\n## Compiler Error:\ncannot borrow as mutable, as it is not declared as mutable\n\n## Fixed Code:", "output": "fn main() { let mut text = String::new(); text.push_str(\"hello\"); }", "task_id": "borrow_checker_missing_mut_057", "family": "borrow_checker", "pattern": "missing_mut"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\n#[allow(clippy::uninlined_format_args)] fn log(level: &str, msg: &str) { eprintln!(\"[{}] {}\", level, msg); }\n```\n\n## Compiler Error:\nclippy::uninlined_format_args: use inline format args instead of suppressing\n\n## Fixed Code:", "output": "fn log(level: &str, msg: &str) { eprintln!(\"[{level}] {msg}\"); }", "task_id": "clippy_suppression_no_suppress_format_args_010", "family": "clippy_suppression", "pattern": "no_suppress_format_args"}
