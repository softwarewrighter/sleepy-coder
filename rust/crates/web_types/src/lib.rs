//! Shared types for sleepy-coder web UI.
//!
//! This crate defines API request/response types and WebSocket messages
//! shared between the Axum backend and Yew frontend.

use chrono::{DateTime, Utc};
use core_types::{ErrorFamily, Task};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Re-export core types for convenience
pub use core_types::{Episode, ErrorFamily as Family, EvalResult, Task as CoreTask};

/// Summary of a task for list views.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskSummary {
    pub id: String,
    pub family: ErrorFamily,
    pub description: String,
    pub passed: Option<bool>,
    pub attempts: u32,
}

impl From<&Task> for TaskSummary {
    fn from(task: &Task) -> Self {
        Self {
            id: task.id.clone(),
            family: task.family,
            description: task.description.clone(),
            passed: None,
            attempts: 0,
        }
    }
}

/// Detailed task view with code.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskDetail {
    pub id: String,
    pub family: ErrorFamily,
    pub description: String,
    pub buggy_code: String,
    pub correct_code: String,
    pub expected_error: Option<String>,
    pub last_attempt: Option<AttemptSummary>,
}

impl From<Task> for TaskDetail {
    fn from(task: Task) -> Self {
        Self {
            id: task.id,
            family: task.family,
            description: task.description,
            buggy_code: task.buggy_code,
            correct_code: task.correct_code,
            expected_error: task.expected_error,
            last_attempt: None,
        }
    }
}

/// Summary of an attempt.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AttemptSummary {
    pub attempt_idx: u32,
    pub passed: bool,
    pub steps: u32,
    pub error_signature: Option<String>,
    pub timestamp: DateTime<Utc>,
}

/// Diff view data.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DiffView {
    pub task_id: String,
    pub original: String,
    pub fixed: String,
    pub diff_unified: String,
}

/// Filter parameters for task list.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct TaskFilter {
    pub family: Option<ErrorFamily>,
    pub passed: Option<bool>,
    pub search: Option<String>,
}

/// Analytics summary.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AnalyticsSummary {
    pub total_tasks: u32,
    pub passed_tasks: u32,
    pub failed_tasks: u32,
    pub pass_rate: f64,
    pub total_attempts: u32,
    pub avg_steps_to_green: f64,
    pub error_family_breakdown: Vec<FamilyStats>,
}

/// Stats for an error family.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FamilyStats {
    pub family: ErrorFamily,
    pub count: u32,
    pub passed: u32,
    pub pass_rate: f64,
}

// === WebSocket Messages ===

/// Session ID for fix sessions.
pub type SessionId = Uuid;

/// Client-to-server WebSocket message.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", content = "payload")]
pub enum WsClientMessage {
    /// Start a fix session for a task.
    StartFix { task_id: String },
    /// Cancel the current fix session.
    CancelFix { session_id: SessionId },
}

/// Server-to-client WebSocket message.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", content = "payload")]
pub enum WsServerMessage {
    /// Fix session started.
    SessionStarted {
        session_id: SessionId,
        task_id: String,
    },
    /// An attempt has started.
    AttemptStarted { attempt_idx: u32 },
    /// Code was generated by the LLM.
    CodeGenerated { code: String },
    /// Compilation result.
    CompileResult {
        success: bool,
        output: String,
        error_signature: Option<String>,
    },
    /// Fix session completed.
    SessionComplete {
        session_id: SessionId,
        passed: bool,
        total_attempts: u32,
        final_code: Option<String>,
        diff_unified: Option<String>,
    },
    /// Error occurred.
    Error { message: String },
}

/// API request to start a fix.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StartFixRequest {
    pub task_id: String,
}

/// API response for starting a fix.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StartFixResponse {
    pub session_id: SessionId,
}

/// Generic API error response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiError {
    pub error: String,
    pub code: Option<String>,
}

impl ApiError {
    pub fn new(error: impl Into<String>) -> Self {
        Self {
            error: error.into(),
            code: None,
        }
    }

    pub fn with_code(error: impl Into<String>, code: impl Into<String>) -> Self {
        Self {
            error: error.into(),
            code: Some(code.into()),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_task_summary_from_task() {
        let task = Task::new(
            "test_001".to_string(),
            ErrorFamily::BorrowChecker,
            "Test task".to_string(),
            "buggy".to_string(),
            "fixed".to_string(),
        );

        let summary = TaskSummary::from(&task);

        assert_eq!(summary.id, "test_001");
        assert_eq!(summary.family, ErrorFamily::BorrowChecker);
        assert!(summary.passed.is_none());
        assert_eq!(summary.attempts, 0);
    }

    #[test]
    fn test_ws_message_serialization() {
        let msg = WsClientMessage::StartFix {
            task_id: "task_001".to_string(),
        };

        let json = serde_json::to_string(&msg).unwrap();
        assert!(json.contains("StartFix"));
        assert!(json.contains("task_001"));

        let parsed: WsClientMessage = serde_json::from_str(&json).unwrap();
        if let WsClientMessage::StartFix { task_id } = parsed {
            assert_eq!(task_id, "task_001");
        } else {
            panic!("Wrong variant");
        }
    }

    #[test]
    fn test_ws_server_message_serialization() {
        let session_id = Uuid::new_v4();
        let msg = WsServerMessage::SessionComplete {
            session_id,
            passed: true,
            total_attempts: 3,
            final_code: Some("fn main() {}".to_string()),
            diff_unified: None,
        };

        let json = serde_json::to_string(&msg).unwrap();
        let parsed: WsServerMessage = serde_json::from_str(&json).unwrap();

        if let WsServerMessage::SessionComplete { passed, .. } = parsed {
            assert!(passed);
        } else {
            panic!("Wrong variant");
        }
    }

    #[test]
    fn test_api_error() {
        let err = ApiError::new("Not found");
        assert_eq!(err.error, "Not found");
        assert!(err.code.is_none());

        let err = ApiError::with_code("Invalid request", "INVALID_REQUEST");
        assert_eq!(err.code, Some("INVALID_REQUEST".to_string()));
    }
}
