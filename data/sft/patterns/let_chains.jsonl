{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn check(opt: Option<i32>) -> bool { if let Some(x) = opt { if x > 0 { return true; } } false }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn check(opt: Option<i32>) -> bool { if let Some(x) = opt && x > 0 { return true; } false }", "task_id": "rust_2024_let_chains_035", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt { if !s.is_empty() { return Some(s); } } None }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt && !s.is_empty() { return Some(s); } None }", "task_id": "rust_2024_let_chains_038", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt { if !s.is_empty() { return Some(s); } } None }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt && !s.is_empty() { return Some(s); } None }", "task_id": "rust_2024_let_chains_037", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn check(opt: Option<i32>) -> bool { if let Some(x) = opt { if x > 0 { return true; } } false }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn check(opt: Option<i32>) -> bool { if let Some(x) = opt && x > 0 { return true; } false }", "task_id": "rust_2024_let_chains_034", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn check(opt: Option<i32>) -> bool { if let Some(x) = opt { if x > 0 { return true; } } false }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn check(opt: Option<i32>) -> bool { if let Some(x) = opt && x > 0 { return true; } false }", "task_id": "rust_2024_let_chains_033", "family": "rust_2024", "pattern": "let_chains"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt { if !s.is_empty() { return Some(s); } } None }\n```\n\n## Compiler Error:\nuse let-chains to combine if-let with conditions\n\n## Fixed Code:", "output": "fn get_valid(opt: Option<String>) -> Option<String> { if let Some(s) = opt && !s.is_empty() { return Some(s); } None }", "task_id": "rust_2024_let_chains_036", "family": "rust_2024", "pattern": "let_chains"}
