{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn handle_request(req: Request) -> Response { let auth = req.headers.get(\"Authorization\"); if auth.is_none() { return Response::unauthorized(); } let token = auth.unwrap(); if !verify_token(token) { return Response::forbidden(); } let body = req.body(); let data: Data = serde_json::from_str(body).unwrap(); let result = db::save(&data); match result { Ok(_) => Response::ok(), Err(e) => Response::error(e) } }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn authenticate(req: &Request) -> Result<&str, Response> { req.headers.get(\"Authorization\").filter(|t| verify_token(t)).ok_or_else(Response::unauthorized) } fn parse_body(req: &Request) -> Result<Data, Response> { serde_json::from_str(req.body()).map_err(|_| Response::bad_request()) } fn handle_request(req: Request) -> Response { let _token = match authenticate(&req) { Ok(t) => t, Err(r) => return r }; match parse_body(&req).and_then(|data| db::save(&data).map_err(|e| Response::error(e))) { Ok(_) => Response::ok(), Err(r) => r } }", "task_id": "complexity_decompose_long_function_005", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn process(data: &str) -> Result<String, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } let parsed: i32 = trimmed.parse().map_err(|_| Error::Parse)?; let validated = if parsed < 0 { return Err(Error::Negative); } else { parsed }; let result = validated * 2 + 10; Ok(format!(\"result: {}\", result)) }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn parse_input(data: &str) -> Result<i32, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } trimmed.parse().map_err(|_| Error::Parse) } fn validate(n: i32) -> Result<i32, Error> { if n < 0 { Err(Error::Negative) } else { Ok(n) } } fn process(data: &str) -> Result<String, Error> { let parsed = parse_input(data)?; let validated = validate(parsed)?; Ok(format!(\"result: {}\", validated * 2 + 10)) }", "task_id": "complexity_decompose_long_function_000", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn handle_request(req: Request) -> Response { let auth = req.headers.get(\"Authorization\"); if auth.is_none() { return Response::unauthorized(); } let token = auth.unwrap(); if !verify_token(token) { return Response::forbidden(); } let body = req.body(); let data: Data = serde_json::from_str(body).unwrap(); let result = db::save(&data); match result { Ok(_) => Response::ok(), Err(e) => Response::error(e) } }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn authenticate(req: &Request) -> Result<&str, Response> { req.headers.get(\"Authorization\").filter(|t| verify_token(t)).ok_or_else(Response::unauthorized) } fn parse_body(req: &Request) -> Result<Data, Response> { serde_json::from_str(req.body()).map_err(|_| Response::bad_request()) } fn handle_request(req: Request) -> Response { let _token = match authenticate(&req) { Ok(t) => t, Err(r) => return r }; match parse_body(&req).and_then(|data| db::save(&data).map_err(|e| Response::error(e))) { Ok(_) => Response::ok(), Err(r) => r } }", "task_id": "complexity_decompose_long_function_003", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn process(data: &str) -> Result<String, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } let parsed: i32 = trimmed.parse().map_err(|_| Error::Parse)?; let validated = if parsed < 0 { return Err(Error::Negative); } else { parsed }; let result = validated * 2 + 10; Ok(format!(\"result: {}\", result)) }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn parse_input(data: &str) -> Result<i32, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } trimmed.parse().map_err(|_| Error::Parse) } fn validate(n: i32) -> Result<i32, Error> { if n < 0 { Err(Error::Negative) } else { Ok(n) } } fn process(data: &str) -> Result<String, Error> { let parsed = parse_input(data)?; let validated = validate(parsed)?; Ok(format!(\"result: {}\", validated * 2 + 10)) }", "task_id": "complexity_decompose_long_function_001", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn handle_request(req: Request) -> Response { let auth = req.headers.get(\"Authorization\"); if auth.is_none() { return Response::unauthorized(); } let token = auth.unwrap(); if !verify_token(token) { return Response::forbidden(); } let body = req.body(); let data: Data = serde_json::from_str(body).unwrap(); let result = db::save(&data); match result { Ok(_) => Response::ok(), Err(e) => Response::error(e) } }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn authenticate(req: &Request) -> Result<&str, Response> { req.headers.get(\"Authorization\").filter(|t| verify_token(t)).ok_or_else(Response::unauthorized) } fn parse_body(req: &Request) -> Result<Data, Response> { serde_json::from_str(req.body()).map_err(|_| Response::bad_request()) } fn handle_request(req: Request) -> Response { let _token = match authenticate(&req) { Ok(t) => t, Err(r) => return r }; match parse_body(&req).and_then(|data| db::save(&data).map_err(|e| Response::error(e))) { Ok(_) => Response::ok(), Err(r) => r } }", "task_id": "complexity_decompose_long_function_004", "family": "complexity", "pattern": "decompose_long_function"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn process(data: &str) -> Result<String, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } let parsed: i32 = trimmed.parse().map_err(|_| Error::Parse)?; let validated = if parsed < 0 { return Err(Error::Negative); } else { parsed }; let result = validated * 2 + 10; Ok(format!(\"result: {}\", result)) }\n```\n\n## Compiler Error:\nfunction too long: decompose into smaller focused functions\n\n## Fixed Code:", "output": "fn parse_input(data: &str) -> Result<i32, Error> { let trimmed = data.trim(); if trimmed.is_empty() { return Err(Error::Empty); } trimmed.parse().map_err(|_| Error::Parse) } fn validate(n: i32) -> Result<i32, Error> { if n < 0 { Err(Error::Negative) } else { Ok(n) } } fn process(data: &str) -> Result<String, Error> { let parsed = parse_input(data)?; let validated = validate(parsed)?; Ok(format!(\"result: {}\", validated * 2 + 10)) }", "task_id": "complexity_decompose_long_function_002", "family": "complexity", "pattern": "decompose_long_function"}
