{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "fn get_name(names: &[String]) -> &str {\n    match names.first() {\n        Some(ref name) => name.as_str(),\n        None => \"unknown\",\n    }\n}\n\nfn main() {\n    let names = vec![\"Alice\".to_string(), \"Bob\".to_string()];\n    println!(\"{}\", get_name(&names));\n}", "output": "fn get_name(names: &[String]) -> &str {\n    match names.first() {\n        Some(name) => name.as_str(),\n        None => \"unknown\",\n    }\n}\n\nfn main() {\n    let names = vec![\"Alice\".to_string(), \"Bob\".to_string()];\n    println!(\"{}\", get_name(&names));\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "fn process_values(data: &Vec<(String, i32)>) {\n    for &(ref key, value) in data {\n        println!(\"{}: {}\", key, value);\n    }\n}\n\nfn main() {\n    let data = vec![(\"a\".to_string(), 1), (\"b\".to_string(), 2)];\n    process_values(&data);\n}", "output": "fn process_values(data: &Vec<(String, i32)>) {\n    for (key, value) in data {\n        println!(\"{}: {}\", key, value);\n    }\n}\n\nfn main() {\n    let data = vec![(\"a\".to_string(), 1), (\"b\".to_string(), 2)];\n    process_values(&data);\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "fn find_max(values: &[i32]) -> Option<i32> {\n    let mut max = None;\n    for &ref val in values {\n        match max {\n            Some(ref current) if current >= val => {}\n            _ => max = Some(*val),\n        }\n    }\n    max\n}\n\nfn main() {\n    let nums = vec![3, 1, 4, 1, 5, 9];\n    println!(\"{:?}\", find_max(&nums));\n}", "output": "fn find_max(values: &[i32]) -> Option<i32> {\n    let mut max = None;\n    for val in values {\n        match max {\n            Some(current) if current >= *val => {}\n            _ => max = Some(*val),\n        }\n    }\n    max\n}\n\nfn main() {\n    let nums = vec![3, 1, 4, 1, 5, 9];\n    println!(\"{:?}\", find_max(&nums));\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "use std::collections::HashMap;\n\nfn get_or_default<'a>(map: &'a HashMap<String, String>, key: &str) -> &'a str {\n    match map.get(key) {\n        Some(ref value) => value.as_str(),\n        None => \"default\",\n    }\n}\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"key\".to_string(), \"value\".to_string());\n    println!(\"{}\", get_or_default(&map, \"key\"));\n}", "output": "use std::collections::HashMap;\n\nfn get_or_default<'a>(map: &'a HashMap<String, String>, key: &str) -> &'a str {\n    match map.get(key) {\n        Some(value) => value.as_str(),\n        None => \"default\",\n    }\n}\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"key\".to_string(), \"value\".to_string());\n    println!(\"{}\", get_or_default(&map, \"key\"));\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
{"instruction": "Fix the Rust 2024 edition compilation error.", "input": "enum Command {\n    Move { x: i32, y: i32 },\n    Print(String),\n    Quit,\n}\n\nfn handle(cmd: &Command) {\n    match cmd {\n        Command::Move { ref x, ref y } => println!(\"Moving to ({}, {})\", x, y),\n        Command::Print(ref msg) => println!(\"{}\", msg),\n        Command::Quit => println!(\"Quitting\"),\n    }\n}\n\nfn main() {\n    handle(&Command::Print(\"hello\".to_string()));\n}", "output": "enum Command {\n    Move { x: i32, y: i32 },\n    Print(String),\n    Quit,\n}\n\nfn handle(cmd: &Command) {\n    match cmd {\n        Command::Move { x, y } => println!(\"Moving to ({}, {})\", x, y),\n        Command::Print(msg) => println!(\"{}\", msg),\n        Command::Quit => println!(\"Quitting\"),\n    }\n}\n\nfn main() {\n    handle(&Command::Print(\"hello\".to_string()));\n}", "pattern": "match_ergonomics_redundant_ref", "error_hint": "binding modifier `ref` is redundant because the default binding mode is already `ref`"}
