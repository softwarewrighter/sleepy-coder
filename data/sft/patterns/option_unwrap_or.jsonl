{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn last_elem(v: &[i32]) -> i32 { *v.last() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn last_elem(v: &[i32]) -> i32 { *v.last().unwrap_or(&0) }", "task_id": "result_handling_option_unwrap_or_011", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn last_elem(v: &[i32]) -> i32 { *v.last() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn last_elem(v: &[i32]) -> i32 { *v.last().unwrap_or(&0) }", "task_id": "result_handling_option_unwrap_or_010", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn first_char(s: &str) -> char { s.chars().next() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn first_char(s: &str) -> char { s.chars().next().unwrap_or(' ') }", "task_id": "result_handling_option_unwrap_or_008", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn last_elem(v: &[i32]) -> i32 { *v.last() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn last_elem(v: &[i32]) -> i32 { *v.last().unwrap_or(&0) }", "task_id": "result_handling_option_unwrap_or_009", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn first_char(s: &str) -> char { s.chars().next() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn first_char(s: &str) -> char { s.chars().next().unwrap_or(' ') }", "task_id": "result_handling_option_unwrap_or_006", "family": "result_handling", "pattern": "option_unwrap_or"}
{"instruction": "You are a Rust expert. Fix the following code that has a compilation error.\nReturn ONLY the fixed Rust code without any explanation or markdown formatting.", "input": "## Buggy Code:\n```rust\nfn first_char(s: &str) -> char { s.chars().next() }\n```\n\n## Compiler Error:\nmismatched types: expected char, found Option<char>: use unwrap_or\n\n## Fixed Code:", "output": "fn first_char(s: &str) -> char { s.chars().next().unwrap_or(' ') }", "task_id": "result_handling_option_unwrap_or_007", "family": "result_handling", "pattern": "option_unwrap_or"}
